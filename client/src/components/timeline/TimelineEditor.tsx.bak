import { useState, useRef, useEffect } from "react";
import { useDispatch, useSelector } from "react-redux";
import {
  addItem,
  updateItem,
  moveItem,
  sortItems,
  undo,
  redo,
  updateWeddingInfo,
  RootState as RootStateType,
  resetTimeline,
  setItems,
  deleteItem,
  setBulkEditMode,
  toggleItemSelection,
  selectAllInCategory,
  clearSelection,
  adjustSelectedTimes,
  deleteSelectedItems,
} from "@/store/timelineSlice";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import {
  Plus,
  Copy,
  Edit2,
  Trash2,
  ArrowUpDown,
  CalendarIcon,
  List,
  PlusIcon,
  MinusIcon,
  ChevronRight,
  ChevronLeft,
  Download,
  FileText,
  X,
  Save,
  GripVertical,
  Undo2,
  Redo2,
  SortAsc,
  FileDown,
  RotateCcw,
  ChevronDown,
  Clock,
  Check,
  Upload,
  Settings,
  Layers,
  RefreshCw,
  Users,
  MapPin,
  ClipboardList,
  ArrowLeft,
  Eye,
} from "lucide-react";
import { format, parse, addMinutes } from "date-fns";
import { jsPDF } from "jspdf";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { TimelineView } from "./TimelineView";
import { useDrag, useDrop } from "react-dnd";
import { Switch } from "@/components/ui/switch";
import { Label } from "@/components/ui/label";
import { useToast } from "@/hooks/use-toast";
import { useQuery } from "@tanstack/react-query";
import { queryClient } from "@/lib/queryClient";
import { Textarea } from "@/components/ui/textarea";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuTrigger,
  DropdownMenuItem,
} from "@/components/ui/dropdown-menu";
import { Checkbox } from "@/components/ui/checkbox";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Popover,
  PopoverTrigger,
  PopoverContent,
} from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Document,
  Paragraph,
  TextRun,
  HeadingLevel,
  Packer,
  Table,
  TableRow,
  TableCell,
  WidthType,
  BorderStyle,
  AlignmentType,
  ImageRun,
  Footer,
  PageNumber,
  NumberFormat,
  HeightRule,
} from "docx";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ScrollArea } from "@/components/ui/scroll-area";
import { cn } from "@/lib/utils";
import { DndProvider } from "react-dnd";
import { HTML5Backend } from "react-dnd-html5-backend";
import { VendorSelector } from "./VendorSelector";
import { VendorBulkAssignDialog } from "./VendorBulkAssignDialog";
import { VendorSelectorDisplay, VendorSelectorDisplayRef } from "./VendorSelectorDisplay";
import { TimelineVendorSelector } from "./TimelineVendorSelector";
import { RootState } from "@/store/store";

interface WeddingInfo {
  names: string;
  date: string;
  type?: string;
  location?: string;
  customFieldValues?: Record<string, string | number | boolean | null>;
  title?: string;
}

interface TimelineSettings {
  eventTypes: EventType[];
  timeIncrement: number;
  durationIncrement: number;
  defaultEventDuration: number;
  exportFooterText: string;
}

interface ExtendedRootState extends RootStateType {
  settings: TimelineSettings;
}

interface EventType {
  type: string;
  description?: string;
  customFields?: CustomField[];
}

interface CustomField {
  id: string;
  name: string;
  type: "text" | "number" | "boolean" | "date";
  defaultValue?: string | number | boolean;
}

interface Category {
  id: string;
  name: string;
  description?: string;
  order: number;
}

interface TimelineEditorProps {
  categories: Category[];
  setCategories: (categories: Category[]) => void;
  showCategories: boolean;
  setShowCategories: (show: boolean) => void;
  showEndTimes: boolean;
  setShowEndTimes: (show: boolean) => void;
  showVendors: boolean;
  setShowVendors: (show: boolean) => void;
  isTemplate?: boolean;
  initialData?: any;
  setItems?: (items: TimelineItem[]) => void;
  items?: TimelineItem[];
  onDeleteItem?: (id: string) => void;
  newItemId?: string | null;
  setNewItemId?: (id: string | null) => void;
}

interface TimelineItem {
  id: string;
  startTime: string;
  endTime: string;
  duration: string;
  title: string;
  description: string;
  location: string;
  type: string;
  category?: string;
  imageUrl?: string;
  caption?: string;
  customFieldValues?: Record<string, string | number | boolean | null>;
  vendors?: Array<{
    id: number;
    name: string;
    type?: {
      id: number;
      name: string;
    } | null;
  }>;
}

interface Template {
  id: number;
  title: string;
  events: TimelineItem[];
  categories: Category[];
  type?: string;
}

interface BulkEditControlsProps {
  onTimeShift: (minutes: { minutes: number }) => void;
  timeAdjustments: number[];
  onSelectAllInCategory: (category: string) => void;
  onClearSelection: () => void;
  selectedCount: number;
  categories: Category[];
  onDeleteSelected: () => void;
}

const eventTypes: EventType[] = [
  {
    type: "Wedding",
    customFields: [
      { id: "wedding-date", name: "Wedding Date", type: "date" },
      {
        id: "wedding-location",
        name: "Location",
        type: "text",
        defaultValue: "",
      },
      { id: "wedding-budget", name: "Budget", type: "number", defaultValue: 0 },
      {
        id: "wedding-confirmed",
        name: "Confirmed",
        type: "boolean",
        defaultValue: false,
      },
    ],
  },
  { type: "Birthday" },
  { type: "Conference" },
  { type: "Reunion" },
  { type: "Other" },
];

interface CategoryEditDialogProps {
  category: Category;
  onSave: (id: string, updates: { name: string; description: string }) => void;
  onCancel: () => void;
  open: boolean;
}

const CategoryEditDialog = ({
  category,
  onSave,
  onCancel,
  open,
}: CategoryEditDialogProps) => {
  const [name, setName] = useState(category.name);
  const [description, setDescription] = useState(category.description || "");

  // Update state when category changes
  useEffect(() => {
    if (category) {
      setName(category.name);
      setDescription(category.description || "");
    }
  }, [category]);

  const handleSave = () => {
    onSave(category.id, { name, description });
  };

  return (
    <Dialog open={open} onOpenChange={() => onCancel()}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>{category.id ? "Edit Category" : "Add Category"}</DialogTitle>
        </DialogHeader>
        <div className="grid gap-4 py-4">
          <div className="grid gap-2">
            <Label htmlFor="name">Name</Label>
            <Input
              id="name"
              value={name}
              onChange={(e) => setName(e.target.value)}
              className="col-span-3"
            />
          </div>
          <div className="grid gap-2">
            <Label htmlFor="description">Description</Label>
            <Textarea
              id="description"
              value={description}
              onChange={(e) => setDescription(e.target.value)}
              className="col-span-3"
            />
          </div>
        </div>
        <DialogFooter>
          <Button variant="outline" onClick={onCancel}>
            Cancel
          </Button>
          <Button onClick={handleSave} disabled={!name.trim()} className="bg-purple-600 hover:bg-purple-700">
            Save
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
};

const CategoryItem = ({
  category,
  index,
  onEdit,
  onDelete,
  moveCategory,
}: {
  category: Category;
  index: number;
  onEdit: () => void;
  onDelete: () => void;
  moveCategory: (dragIndex: number, hoverIndex: number) => void;
}) => {
  const ref = useRef<HTMLDivElement>(null);
  
  const [{ isDragging }, drag] = useDrag({
    type: "CATEGORY",
    item: { type: "CATEGORY", id: category.id, index },
    collect: (monitor) => ({
      isDragging: monitor.isDragging(),
    }),
  });

  const [, drop] = useDrop({
    accept: "CATEGORY",
    hover(item: any, monitor) {
      if (!ref.current) return;
      const dragIndex = item.index;
      const hoverIndex = index;
      if (dragIndex === hoverIndex) return;
      moveCategory(dragIndex, hoverIndex);
      item.index = hoverIndex;
    },
  });

  drag(drop(ref));

  return (
    <div
      ref={ref}
      className={`rounded-md border border-gray-200 dark:border-gray-600 overflow-hidden group transition-colors ${
        isDragging ? "opacity-50" : ""
      }`}
    >
      <div className="bg-white dark:bg-slate-800 p-3 hover:bg-gray-50 dark:hover:bg-slate-700 transition-colors">
        <div className="flex items-center gap-2">
          <GripVertical className="h-4 w-4 cursor-move text-gray-400 group-hover:text-purple-600 flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity" />
          <div className="flex-1 min-w-0">
            <div className="flex items-center justify-between gap-2 mb-0.5">
              <span className="font-medium text-lg text-foreground">
                {category.name}
              </span>
              <div className="flex gap-1 flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity">
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-8 w-8 p-0"
                  onClick={onEdit}
                >
                  <Edit2 className="h-4 w-4 text-purple-600" />
                </Button>
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-8 w-8 p-0 hover:text-destructive"
                  onClick={onDelete}
                >
                  <X className="h-4 w-4 text-purple-600 hover:text-red-500" />
                </Button>
              </div>
            </div>
            {category.description && (
              <div>
                <p className="text-sm text-muted-foreground whitespace-pre-wrap">
                  {category.description}
                </p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

const BulkEditControls = ({
  onTimeShift,
  timeAdjustments,
  onSelectAllInCategory,
  onClearSelection,
  selectedCount,
  categories,
  onDeleteSelected,
}: BulkEditControlsProps) => {
  const [showDeleteDialog, setShowDeleteDialog] = useState(false);
  const selectedItems = useSelector(
    (state: RootStateType) => state.timeline.selectedItems,
  );
  const timelineItems = useSelector(
    (state: RootStateType) => state.timeline.items,
  );

  const selectedCategories = categories.reduce(
    (acc: { [key: string]: boolean }, category) => {
      const categoryItems = timelineItems.filter(
        (item) => item.category === category.name,
      );
      const selectedCategoryItems = categoryItems.filter((item) =>
        selectedItems.includes(item.id),
      );
      acc[category.name] =
        categoryItems.length > 0 &&
        categoryItems.length === selectedCategoryItems.length;
      return acc;
    },
    {},
  );

  return (
    <div className="p-4 bg-card rounded-lg border mb-6">
      <div className="flex items-center justify-between mb-3">
        <h3 className="text-lg font-medium">Bulk Edit Mode</h3>
        <div className="text-sm font-medium px-2 py-1 bg-purple-100 dark:bg-purple-900/30 text-purple-800 dark:text-purple-200 rounded-full">
          {selectedCount} items selected
        </div>
      </div>

      <div className="space-y-3">
        {/* Time Adjustments Section */}
        <div>
          <h4 className="mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">Time Adjustments</h4>
          <div className="grid grid-cols-2 gap-2">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" size="sm" className="w-full">
                  <ChevronLeft className="h-4 w-4 mr-1 text-purple-600" />
                  Earlier
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent>
                {timeAdjustments.map((minutes) => (
                  <DropdownMenuItem
                    key={`earlier-${minutes}`}
                    onClick={() => onTimeShift({ minutes: -minutes })}
                  >
                    {minutes} minutes earlier
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>

            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="outline" size="sm" className="w-full">
                  Later
                  <ChevronRight className="h-4 w-4 ml-1 text-purple-600" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent>
                {timeAdjustments.map((minutes) => (
                  <DropdownMenuItem
                    key={`later-${minutes}`}
                    onClick={() => onTimeShift({ minutes })}
                  >
                    {minutes} minutes later
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>

        {/* Select by Category Section */}
        <div>
          <h4 className="mb-2 text-sm font-medium text-gray-700 dark:text-gray-300">Select by Category</h4>
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2">
            {categories.map((category) => (
              <Button
                key={category.id}
                variant={
                  selectedCategories[category.name] ? "default" : "outline"
                }
                size="sm"
                onClick={() => onSelectAllInCategory(category.name)}
                className={`justify-start text-sm h-8 ${
                  selectedCategories[category.name] ? "bg-purple-600 hover:bg-purple-700 text-white" : ""
                }`}
              >
                <span className="truncate">{category.name}</span>
              </Button>
            ))}
          </div>
        </div>

        {/* Actions Section */}
        <div className="grid grid-cols-2 gap-2 pt-1">
          <Button
            variant="outline"
            size="sm"
            onClick={onClearSelection}
            className="h-9"
          >
            Deselect All
          </Button>
          <Button
            variant="destructive"
            size="sm"
            onClick={() => setShowDeleteDialog(true)}
            className="h-9"
          >
            Delete Selected
          </Button>
        </div>
      </div>

      <AlertDialog open={showDeleteDialog} onOpenChange={setShowDeleteDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Delete Selected Items</AlertDialogTitle>
            <AlertDialogDescription>
              Are you sure you want to delete {selectedCount} selected items?
              This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="bg-white hover:bg-gray-100 dark:bg-slate-800 dark:hover:bg-slate-700">
              Cancel
            </AlertDialogCancel>
            <AlertDialogAction
              onClick={() => {
                onDeleteSelected();
                setShowDeleteDialog(false);
              }}
              className="bg-purple-600 hover:bg-purple-700"
            >
              Delete
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>
    </div>
  );
};

export function TimelineEditor({
  categories,
  setCategories,
  showCategories,
  setShowCategories,
  showEndTimes,
  setShowEndTimes,
  showVendors,
  setShowVendors,
  isTemplate = false,
  items: propItems,
  setItems: setTemplateItems,
  onDeleteItem,
}: TimelineEditorProps) {
  const pathId = window.location.pathname.split("/").pop() || "";
  const timelineId = !isTemplate && pathId && /^\d+$/.test(pathId)
    ? parseInt(pathId)
    : null;
  
  // Debug log
  useEffect(() => {
    console.log("TimelineEditor - Path ID:", pathId);
    console.log("TimelineEditor - Timeline ID:", timelineId);
  }, [pathId, timelineId]);

  const dispatch = useDispatch();
  
  const [newCategory, setNewCategory] = useState("");
  const [editingCategory, setEditingCategory] = useState<Category | null>(null);
  const [saveTemplateDialogOpen, setSaveTemplateDialogOpen] = useState(false);
  const [templateName, setTemplateName] = useState("");
  const [showTemplateConfirmDialog, setShowTemplateConfirmDialog] =
    useState(false);
  const [templateToApply, setTemplateToApply] = useState<number | null>(null);
  const { toast } = useToast();
  const [localShowCategories, setLocalShowCategories] = useState(showCategories);
  const [showResetDialog, setShowResetDialog] = useState(false);
  const [localNewItemId, setLocalNewItemId] = useState<string | null>(null);
  const [showExportDialog, setShowExportDialog] = useState(false);
  const [showExportPreview, setShowExportPreview] = useState(false);
  const [exportOptions, setExportOptions] = useState({
    showCategories: true,
    showIcons: true,
    includeUserInfo: true,
    showDurations: true,
    showLocations: true,
    showDescriptions: true,
    showEndTimes: true,
    includeImages: true,
    showParticipants: true,
    showContactName: true,
    showEmail: true,
    showPhone: true,
    showAddress: true,
    showNotes: true,
    showVendorTypes: true,
    showAdditionalDetails: true, // Restored for custom fields
    showItemParticipants: true, // New option for showing participants for each timeline item
  });
  const [showLocations, setShowLocations] = useState(true);
  const [showDescriptions, setShowDescriptions] = useState(true);
  const [previewContent, setPreviewContent] = useState("");
  const [showTimelineInfo, setShowTimelineInfo] = useState(false);
  const [showTimelineDetails, setShowTimelineDetails] = useState(false);

  const [showVendorsContent, setShowVendorsContent] = useState(false);
  const [showViewOptions, setShowViewOptions] = useState(false);
  const [showBulkVendorDialog, setShowBulkVendorDialog] = useState(false);
  const [showCategoriesSection, setShowCategoriesSection] = useState(false);
  const [showCategoryDialog, setShowCategoryDialog] = useState(false);
  const [localShowEndTimes, setLocalShowEndTimes] = useState(showEndTimes);
  const timelineVendorDisplayRef = useRef<VendorSelectorDisplayRef>(null);
  // Add a new state variable for the Settings section
  const [showSettings, setShowSettings] = useState(false);
  // Add showDurations state
  const [showDurations, setShowDurations] = useState(true);
  const [showIcons, setShowIcons] = useState(true);
  const [showCategoriesOnItems, setShowCategoriesOnItems] = useState(true);
  const [showVendorsOnItems, setShowVendorsOnItems] = useState(true);
  const [showVendorTypes, setShowVendorTypes] = useState(true);
  const [timelineParticipants, setTimelineParticipants] = useState<any[]>([]);
  const [templates, setTemplates] = useState<Template[]>([]);

  const {
    weddingInfo,
    items: timelineItems,
    selectedItems,
    canUndo,
    canRedo,
    bulkEditMode,
  } = useSelector((state: ExtendedRootState) => state.timeline);

  const [stateItems, setStateItems] = useState<TimelineItem[]>(propItems || timelineItems || []);

  useEffect(() => {
    setLocalShowEndTimes(showEndTimes);
  }, [showEndTimes]);

  useEffect(() => {
    if (!isTemplate && timelineItems) {
      setStateItems(timelineItems);
    }
  }, [isTemplate, timelineItems]);

  const {
    eventTypes: reduxEventTypes,
    timeIncrement,
    durationIncrement,
    defaultEventDuration,
    exportFooterText,
  } = useSelector((state: ExtendedRootState) => state.settings);

  const {
    data: timelineImages,
    isLoading: imagesLoading,
    error: imagesError,
  } = useQuery({
    queryKey: ["timelineImages"],
    queryFn: async () => {
      const response = await fetch("/api/timeline-images");
      if (!response.ok) {
        throw new Error("Failed to fetch timeline images");
      }
      return response.json();
    },
  });

  // Add a query to fetch templates
  const {
    data: templatesData,
    isLoading: templatesLoading,
  } = useQuery({
    queryKey: ["templates"],
    queryFn: async () => {
      const response = await fetch("/api/templates");
      if (!response.ok) {
        throw new Error("Failed to fetch templates");
      }
      return response.json();
    },
    enabled: !isTemplate, // Only fetch templates when not in template mode
  });

  // Update templates state when data is fetched
  useEffect(() => {
    if (templatesData) {
      setTemplates(Array.isArray(templatesData) ? templatesData : []);
    }
  }, [templatesData]);

  useEffect(() => {
    if (templateToApply !== null) {
      setShowTemplateConfirmDialog(true);
    }
  }, [templateToApply]);

  useEffect(() => {
    console.log("Categories state changed:", showCategories);
    setLocalShowCategories(showCategories);
  }, [showCategories]);

  const generatePreview = async (): Promise<string> => {
    try {
      // Fetch vendors for items if needed
      let itemsWithVendors = [...(isTemplate && propItems ? propItems : timelineItems)];
      if (exportOptions.showItemParticipants) {
        itemsWithVendors = await Promise.all(
          itemsWithVendors.map(async (item) => {
            if (item.id) {
              try {
                const response = await fetch(`/api/timeline-events/${item.id}/vendors`);
                if (response.ok) {
                  const vendors = await response.json();
                  console.log(`Preview: Fetched vendors for item ${item.id}:`, vendors);
                  return { ...item, vendors };
                }
              } catch (error) {
                console.error("Error fetching vendors for item:", error);
              }
            }
            return item;
          })
        );
      }

      let previewHtml = `
        <div class="p-4 bg-white rounded-lg shadow">
          <h1 class="text-2xl font-bold text-center mb-4">${(weddingInfo as any).title || "Timeline"}</h1>
      `;

      if (weddingInfo.date) {
        previewHtml += `
          <p class="text-center text-gray-600 mb-6">${format(new Date(weddingInfo.date), "MMMM d, yyyy")}</p>
        `;
      }

      if (exportOptions.includeUserInfo) {
        previewHtml += `
          <div class="mb-6 text-center text-gray-600">
            <p>${weddingInfo.names || ""}</p>
            ${weddingInfo.location ? `<p>${weddingInfo.location}</p>` : ""}
          </div>
        `;
      }

      // Add participants table if needed
      if (exportOptions.showParticipants && timelineParticipants.length > 0) {
        previewHtml += `
          <div class="mb-6">
            <h2 class="text-xl font-semibold mb-2">Participants</h2>
            <div class="overflow-x-auto">
              <table class="min-w-full border-collapse">
                <thead>
                  <tr class="bg-gray-100">
                    <th class="p-2 text-left">Name</th>
        `;

        if (exportOptions.showContactName) previewHtml += `<th class="p-2 text-left">Contact Name</th>`;
        if (exportOptions.showEmail) previewHtml += `<th class="p-2 text-left">Email</th>`;
        if (exportOptions.showPhone) previewHtml += `<th class="p-2 text-left">Phone</th>`;
        if (exportOptions.showAddress) {
          previewHtml += `<th class="p-2 text-left">Address</th>`;
        }
        if (exportOptions.showNotes) {
          previewHtml += `<th class="p-2 text-left">Notes</th>`;
        }

        previewHtml += `
                  </tr>
                </thead>
                <tbody>
        `;

        timelineParticipants.forEach((participant) => {
          previewHtml += `
            <tr class="border-t">
              <td class="p-2">${participant.name}${participant.type ? ` (${participant.type.name})` : ""}</td>
          `;

          if (exportOptions.showContactName) {
            previewHtml += `<td class="p-2">${participant.contactName || ""}</td>`;
          }

          if (exportOptions.showEmail) {
            previewHtml += `<td class="p-2">${participant.email || ""}</td>`;
          }

          if (exportOptions.showPhone) {
            previewHtml += `<td class="p-2">${participant.phone || ""}</td>`;
          }

          if (exportOptions.showAddress) {
            previewHtml += `<td class="p-2">${participant.address || ""}</td>`;
          }

          if (exportOptions.showNotes) {
            previewHtml += `<td class="p-2">${participant.notes || ""}</td>`;
          }

          previewHtml += `</tr>`;
        });

        previewHtml += `
                </tbody>
              </table>
            </div>
          </div>
        `;
      }

      // Sort items by start time
      const sortedItems = [...itemsWithVendors].sort((a, b) =>
        a.startTime.localeCompare(b.startTime)
      );

      // Group by category if needed
      if (exportOptions.showCategories && categories.length > 0) {
        const itemsByCategory = sortedItems.reduce((acc: { [key: string]: TimelineItem[] }, item) => {
          const category = item.category || "Uncategorized";
          if (!acc[category]) {
            acc[category] = [];
          }
          acc[category].push(item);
          return acc;
        }, {});

        Object.entries(itemsByCategory).forEach(([categoryName, categoryItems]) => {
          previewHtml += `<div class="mb-6">`;
          previewHtml += `<h2 class="text-xl font-semibold mb-2">${categoryName}</h2>`;

          categoryItems.forEach((item) => {
            previewHtml += `<div class="mb-3 pb-3 border-b">`;
            previewHtml += `<div class="flex justify-between">`;
            previewHtml += `<span class="font-medium">${item.startTime}</span>`;
            if (exportOptions.showEndTimes) {
              previewHtml += `<span class="text-gray-500">End: ${item.endTime}</span>`;
            }
            previewHtml += `</div>`;
            
            previewHtml += `<div class="font-semibold mt-1">${item.title}</div>`;
            
            if (exportOptions.showDescriptions && item.description) {
              previewHtml += `<div class="text-gray-700 mt-1">${item.description}</div>`;
            }

            if (exportOptions.showLocations && item.location) {
              previewHtml += `<div class="text-gray-600 mt-1">Location: ${item.location}</div>`;
            }

            if (exportOptions.showItemParticipants && 'vendors' in item && Array.isArray((item as any).vendors) && (item as any).vendors.length > 0) {
              previewHtml += `<div class="text-gray-600 mt-1">Participants: ${
                (item as any).vendors.map((v: any) => {
                  const vendorName = v.vendor?.name || v.name || "Unnamed";
                  const vendorType = v.vendor?.type?.name || v.type?.name || "";
                  return vendorName + (vendorType && exportOptions.showVendorTypes ? ` (${vendorType})` : "");
                }).join(", ")
              }</div>`;
            }
            
            previewHtml += `</div>`;
          });
          
          previewHtml += `</div>`;
        });
      } else {
        // No categories, just list all items chronologically
        sortedItems.forEach((item) => {
          previewHtml += `<div class="mb-3 pb-3 border-b">`;
          previewHtml += `<div class="flex justify-between">`;
          previewHtml += `<span class="font-medium">${item.startTime}</span>`;
          if (exportOptions.showEndTimes) {
            previewHtml += `<span class="text-gray-500">End: ${item.endTime}</span>`;
          }
          previewHtml += `</div>`;
          
          previewHtml += `<div class="font-semibold mt-1">${item.title}</div>`;
          
          if (exportOptions.showDescriptions && item.description) {
            previewHtml += `<div class="text-gray-700 mt-1">${item.description}</div>`;
          }

          if (exportOptions.showLocations && item.location) {
            previewHtml += `<div class="text-gray-600 mt-1">Location: ${item.location}</div>`;
          }

          if (exportOptions.showItemParticipants && 'vendors' in item && Array.isArray((item as any).vendors) && (item as any).vendors.length > 0) {
            previewHtml += `<div class="text-gray-600 mt-1">Participants: ${
              (item as any).vendors.map((v: any) => {
                const vendorName = v.vendor?.name || v.name || "Unnamed";
                const vendorType = v.vendor?.type?.name || v.type?.name || "";
                return vendorName + (vendorType && exportOptions.showVendorTypes ? ` (${vendorType})` : "");
              }).join(", ")
            }</div>`;
          }
          
          previewHtml += `</div>`;
        });
      }
      
      return previewHtml;
    } catch (error) {
      console.error("Error generating preview:", error);
      return `<div class="text-red-500">Error generating preview: ${error}</div>`;
    }
  };

  useEffect(() => {
    if (showExportDialog) {
      generatePreview().then((preview) => setPreviewContent(preview));
    }
  }, [showExportDialog, exportOptions]);

  const handleAddItem = (
    category?: string,
    position?: number,
    prevItemIndex?: number,
  ) => {
    let startTime = "12:00";
    let location = "";

    const items = isTemplate && propItems ? propItems : timelineItems;

    const relevantItems =
      localShowCategories && category
        ? items.filter((item) => item.category === category)
        : items;

    const sortedItems = [...relevantItems].sort((a, b) =>
      a.startTime.localeCompare(b.startTime),
    );

    if (typeof position === "number" && position > 0) {
      if (
        prevItemIndex !== undefined &&
        prevItemIndex >= 0 &&
        prevItemIndex < sortedItems.length
      ) {
        const previousItem = sortedItems[prevItemIndex];
        const startDate = parse(previousItem.startTime, "HH:mm", new Date());
        const endDate = addMinutes(startDate, parseInt(previousItem.duration));
        startTime = format(endDate, "HH:mm");
        location = previousItem.location || "";
      }
    } else if (items.length > 0) {
      location = items[0].location || "";
    }

    const newItemId = Date.now().toString();
    const newItem: TimelineItem = {
      id: newItemId,
      startTime,
      endTime: startTime,
      duration: defaultEventDuration?.toString() || "60",
      title: "New Event",
      description: "",
      location,
      type: "event",
      category,
    };

    if (isTemplate && setTemplateItems && propItems) {
      const newItems = [...propItems];
      if (typeof position === "number") {
        let insertPosition = position;
        if (localShowCategories && category) {
          const categoryItemsBeforePosition = propItems.filter(
            (item) =>
              item.category === category &&
              item.startTime <= sortedItems[prevItemIndex || 0]?.startTime,
          ).length;
          insertPosition = categoryItemsBeforePosition + 1;
        }
        newItems.splice(insertPosition, 0, newItem);
      } else {
        newItems.push(newItem);
      }
      setTemplateItems(newItems);
    } else {
      if (typeof position === "number") {
        const updatedItems = [...timelineItems];
        let insertPosition = position;
        if (localShowCategories && category) {
          const categoryItemsBeforePosition = timelineItems.filter(
            (item) =>
              item.category === category &&
              item.startTime <= sortedItems[prevItemIndex || 0]?.startTime,
          ).length;
          insertPosition = categoryItemsBeforePosition + 1;
        }
        updatedItems.splice(insertPosition, 0, newItem);
        dispatch(setItems(updatedItems));
      } else {
        dispatch(addItem(newItem));
      }
    }

    setLocalNewItemId(newItemId);

    setTimeout(() => {
      setLocalNewItemId(null);
    }, 100);
  };

  const handleAddCategory = () => {
    setEditingCategory({ id: "", name: "", description: "", order: categories.length });
    setShowCategoryDialog(true);
  };

  const handleEditCategory = (id: string, updates: { name: string; description: string }) => {
    if (id) {
      const oldCategory = categories.find(cat => cat.id === id);
      const updatedCategories = categories.map((cat) =>
        cat.id === id ? { ...cat, ...updates } : cat
      );
      setCategories(updatedCategories);
      
      if (oldCategory && oldCategory.name !== updates.name) {
        if (isTemplate && setTemplateItems && propItems) {
          setTemplateItems(
            propItems.map((item) => 
              item.category === oldCategory.name 
                ? { ...item, category: updates.name } 
                : item
            )
          );
        } else {
          dispatch(
            setItems(
              timelineItems.map((item) => 
                item.category === oldCategory.name 
                  ? { ...item, category: updates.name } 
                  : item
              )
            )
          );
        }
      }
    } else {
      const newCat = {
        id: Date.now().toString(),
        name: updates.name,
        description: updates.description,
        order: categories.length,
      };
      
      setCategories([...categories, newCat]);
      
      if (categories.length === 0) {
        if (isTemplate && setTemplateItems && propItems) {
          setTemplateItems(
            propItems.map((item) => ({ ...item, category: updates.name }))
          );
        } else {
          dispatch(
            setItems(
              timelineItems.map((item) => ({ ...item, category: updates.name }))
            )
          );
        }
      }
    }
    
    setShowCategoryDialog(false);
    setEditingCategory(null);
  };

  const handleDeleteCategory = (categoryId: string) => {
    const categoryToDelete = categories.find((cat) => cat.id === categoryId);
    if (categoryToDelete) {
      const remainingCategories = categories.filter(
        (cat) => cat.id !== categoryId,
      );
      setCategories(remainingCategories);

      if (isTemplate && setTemplateItems && propItems) {
        setTemplateItems(
          propItems.map((item) => {
            if (item.category === categoryToDelete.name) {
              return { ...item, category: undefined };
            }
            return item;
          }),
        );
      } else {
        dispatch(
          setItems(
            timelineItems.map((item) => {
              if (item.category === categoryToDelete.name) {
                return { ...item, category: undefined };
              }
              return item;
            }),
          ),
        );
      }
    }
  };

  const moveCategory = (dragIndex: number, hoverIndex: number) => {
    const newCategories = [...categories];
    const [removed] = newCategories.splice(dragIndex, 1);
    newCategories.splice(hoverIndex, 0, removed);
    setCategories(newCategories);
  };

  const handleReset = () => {
    setShowResetDialog(true);
  };

  const handleResetConfirm = () => {
    dispatch(resetTimeline());
    setCategories([]);
    setLocalShowCategories(false);
    setShowCategories(false);
    setShowResetDialog(false);
  };

  const applyTemplate = async (templateId: number) => {
    try {
      const response = await fetch(`/api/templates/${templateId}`);
      if (!response.ok) {
        throw new Error("Failed to fetch template");
      }

      // Just set the template ID to trigger the confirmation dialog
      // The actual template data will be fetched again in handleTemplateConfirm
      setTemplateToApply(templateId);
    } catch (error) {
      console.error("Template fetch error:", error);
      toast({
        title: "Error",
        description:
          error instanceof Error ? error.message : "Failed to fetch template",
        variant: "destructive",
      });
    }
  };

  const handleTemplateConfirm = async () => {
    if (!templateToApply) return;

    try {
      const response = await fetch(`/api/templates/${templateToApply}`);
      if (!response.ok) {
        throw new Error("Failed to fetch template");
      }

      const template = await response.json();
      console.log("Template data received:", JSON.stringify(template, null, 2));

      // Create new categories with unique IDs
      const newCategories = template.categories.map(
        (cat: any, index: number) => ({
          id: Date.now().toString() + index,
          name: cat.name,
          description: cat.description || "",
          order: cat.order || 0,
        }),
      );
      console.log("New categories created:", newCategories);

      // Update the categories state
      setCategories(newCategories);
      setLocalShowCategories(true);
      setShowCategories(true);

      // Map template events to timeline items
      const templateEvents = template.events.map((event: any, index: number) => {
        console.log(`Processing event ${index}:`, event);
        
        // Keep the original category name from the event
        const categoryName = event.category;
        
        const newEvent = {
          id: Date.now().toString() + index,
          startTime: event.startTime,
          endTime: calculateEndTime(event.startTime, event.duration),
          duration: event.duration,
          title: event.title,
          description: event.description || "",
          location: event.location || "",
          type: event.type || "event",
          category: categoryName, // Use the category name directly
          imageUrl: event.imageUrl || "",
          caption: event.caption || "",
          customFieldValues: event.customFieldValues || {},
        };
        return newEvent;
      });
      console.log("Template events created:", templateEvents);

      // Update the timeline items
      if (isTemplate && setTemplateItems && propItems) {
        console.log("Setting template items");
        setTemplateItems(templateEvents);
      } else {
        console.log("Dispatching setItems action");
        dispatch(setItems(templateEvents));
      }

      // Show success message
      toast({
        title: "Success",
        description: "Template applied successfully",
      });
    } catch (error) {
      console.error("Template application error:", error);
      toast({
        title: "Error",
        description:
          error instanceof Error ? error.message : "Failed to apply template",
        variant: "destructive",
      });
    } finally {
      setTemplateToApply(null);
      setShowTemplateConfirmDialog(false);
    }
  };

  const exportToCSV = () => {
    const items = isTemplate && propItems ? propItems : timelineItems;
    const sortedItems = [...items].sort((a, b) =>
      a.startTime.localeCompare(b.startTime),
    );

    const csvRows = [
      [
        "Category",
        "Start Time",
        "End Time",
        "Duration (min)",
        "Title",
        "Description",
        "Location",
        "Type",
      ].join(","),
      ...sortedItems.map((item) =>
        [
          item.category || "",
          item.startTime,
          calculateEndTime(item.startTime, item.duration),
          item.duration,
          `"${item.title.replace(/"/g, '""')}"`,
          `"${item.description.replace(/"/g, '""')}"`,
          `"${item.location.replace(/"/g, '""')}"`,
          item.type,
        ].join(","),
      ),
    ];

    const csvContent = csvRows.join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = `${getFormattedFilename()}.csv`;
    link.click();
  };

  const calculateEndTime = (startTime: string, duration: string): string => {
    const [hours, minutes] = startTime.split(":").map(Number);
    const durationMinutes = parseInt(duration);

    const totalMinutes = hours * 60 + minutes + durationMinutes;
    const endHours = Math.floor(totalMinutes / 60) % 24;
    const endMinutes = totalMinutes % 60;

    return `${endHours.toString().padStart(2, "0")}:${endMinutes.toString().padStart(2, "0")}`;
  };

  const exportToPDF = async () => {
    // Debug timelineImages
    console.log("PDF Export - timelineImages:", timelineImages);
    console.log("PDF Export - exportOptions:", exportOptions);
    
    // Fetch participants if needed
    if (exportOptions.showParticipants && timelineParticipants.length === 0) {
      await fetchTimelineParticipants();
    }
    
    console.log('Export options:', exportOptions);
    console.log('Timeline participants:', timelineParticipants);
    
    const pdf = new jsPDF("p", "mm", "a4");
    const pdfWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20;
    let yPosition = margin;
    let pageNumber = 1;
    const footerMargin = 20;
    const footerHeight = 15;

    // Function to add footer with page numbers
    const addFooter = (currentPage: number) => {
      const footerY = pageHeight - footerMargin;

      // Add page numbers
      pdf.setFontSize(10);
      pdf.setFont("helvetica", "italic");
      pdf.setTextColor(128, 128, 128);
      pdf.text(`Page ${currentPage}`, pdfWidth / 2, footerY, {
        align: "center",
      });

      // Add footer text below page numbers if it exists
      if (exportOptions.includeUserInfo && exportFooterText) {
        pdf.setFontSize(8);
        pdf.setTextColor(128, 128, 128);
        pdf.text(exportFooterText, pdfWidth / 2, footerY + 5, {
          align: "center",
        });
      }
    };

    // Pre-calculate total pages
    const items = isTemplate && propItems ? propItems : timelineItems;
    const sortedItems = [...items].sort((a, b) =>
      a.startTime.localeCompare(b.startTime),
    );

    // Fetch vendors for items if needed
    const itemsWithVendors = exportOptions.showParticipants 
      ? await Promise.all(
          sortedItems.map(async (item) => {
            if (item.id) {
              try {
                const response = await fetch(`/api/timeline-events/${item.id}/vendors`);
                if (response.ok) {
                  const vendors = await response.json();
                  console.log(`PDF: Fetched vendors for item ${item.id}:`, vendors);
                  return { ...item, vendors };
                }
              } catch (error) {
                console.error("Error fetching vendors for item:", error);
              }
            }
            return item;
          })
        )
      : sortedItems;
      
    console.log("PDF: itemsWithVendors:", itemsWithVendors);

    let totalPages = 1;
    let tempY = yPosition;

    // Title and basic info
    tempY += 30; // Account for title section

    // Calculate pages needed for items
    itemsWithVendors.forEach((item) => {
      const itemHeight = 7; // Basic height for time and title
      const descriptionLines =
        item.description && exportOptions.showDescriptions
          ? pdf.splitTextToSize(item.description, pdfWidth - margin * 2 - 40)
              .length
          : 0;

      tempY += itemHeight + descriptionLines * 5 + (item.location ? 7 : 0) + 5;

      if (tempY > pageHeight - (footerMargin + footerHeight)) {
        totalPages++;
        tempY = margin;
      }
    });

    // Reset position for actual content
    yPosition = margin;

    const addNewPage = () => {
      addFooter(pageNumber);
      pdf.addPage();
      pageNumber++;
      yPosition = margin;
    };

    // Add title and info
    pdf.setFontSize(24);
    pdf.setTextColor(0, 0, 0);
    const titleEventType = weddingInfo.type || "Event";
    const title = `${titleEventType} Timeline`;
    pdf.text(title, pdfWidth / 2, yPosition, { align: "center" });
    yPosition += 10;

    if (weddingInfo.names) {
      pdf.setFontSize(20);
      pdf.text(weddingInfo.names, pdfWidth / 2, yPosition, { align: "center" });
      yPosition += 10;
    }

    if (weddingInfo.date) {
      pdf.setFontSize(14);
      pdf.text(
        format(new Date(weddingInfo.date), "EEEE d MMMM yyyy"), pdfWidth / 2, yPosition, { align: "center" },
      );
      yPosition += 10;
    }

    // Add location if available
    if (weddingInfo.location) {
      pdf.setFontSize(14);
      const location = `Location: ${weddingInfo.location}`
      pdf.text(location, pdfWidth / 2, yPosition, { align: "center" });
      yPosition += 10;
    }

    const selectedEventType = reduxEventTypes.find(
      (et) => et.type === weddingInfo.type,
    );

    // Add Timeline Details section first
    const eventType = reduxEventTypes.find(
      (et) => et.type === weddingInfo.type,
    );
    if (exportOptions.showAdditionalDetails && eventType?.customFields) {
      pdf.setFontSize(14);
      pdf.setTextColor(0, 0, 0);
      pdf.setFont("helvetica", "bold");
      yPosition += 10;
      
      // Check if we need a new page for custom fields
      if (yPosition > pageHeight - (footerMargin + footerHeight + 40)) {
        addNewPage();
      }
      
      pdf.text("Timeline Details", pdfWidth / 2, yPosition, {
        align: "center",
      });
      yPosition += 10;

      eventType.customFields.forEach((field) => {
        const value = weddingInfo.customFieldValues?.[field.id];
        if (value !== undefined && value !== null) {
          let displayValue = value;
          if (field.type === "date") {
            displayValue = format(new Date(value as string), "PPP");
          } else if (field.type === "boolean") {
            displayValue = value ? "Yes" : "No";
          }

          pdf.setFont("helvetica", "bold");
          pdf.setFontSize(10);
          pdf.text(`${field.name}:`, margin, yPosition);
          pdf.setFont("helvetica", "normal");
          pdf.text(
            displayValue.toString(),
            margin + 40,
            yPosition,
          );
          yPosition += 7;
        }
      });
      
      yPosition += 10;
    }
    
    // Add Participants section next
    if (exportOptions.showParticipants && timelineParticipants.length > 0) {
      // Check if we need a new page
      if (yPosition > pageHeight - (footerMargin + footerHeight + 60)) {
        addNewPage();
      }
      
      // Add Participants heading
      pdf.setFontSize(14);
      pdf.setTextColor(0, 0, 0);
      pdf.setFont("helvetica", "bold");
      //yPosition += 10;
      pdf.text("Participants", pdfWidth / 2, yPosition, {
        align: "center",
      });
      yPosition += 10;
      
      // Define table columns based on selected options
      const columns = ["Participant"];
      if (exportOptions.showContactName) columns.push("Contact Name");
      if (exportOptions.showEmail) columns.push("Email");
      if (exportOptions.showPhone) columns.push("Phone");
      if (exportOptions.showAddress) columns.push("Address");
      if (exportOptions.showNotes) columns.push("Notes");
      
      // Calculate column widths
      const tableWidth = pdfWidth - margin * 2;
      const colWidths = columns.map(() => tableWidth / columns.length);
      const cellPadding = 2;
      
      // Set up table headers
      pdf.setFontSize(9);
      pdf.setFont("helvetica", "bold");
      pdf.setTextColor(0, 0, 0);
      
      // Draw table outer border
      pdf.setDrawColor(180, 180, 180);
      pdf.setLineWidth(0.5);
      
      // Draw header cells
      let xPos = margin + cellPadding;
      columns.forEach((col, index) => {
        // Center the header text in the cell
        const headerWidth = colWidths[index] - (cellPadding * 2);
        const textWidth = pdf.getStringUnitWidth(col) * pdf.getFontSize() / pdf.internal.scaleFactor;
        const textX = xPos + (headerWidth - textWidth) / 2;
        
        pdf.text(col, textX, yPosition);
        xPos += colWidths[index];
      });
      
      // Draw header row top and bottom lines
      pdf.line(margin, yPosition - 5, margin + tableWidth, yPosition - 5);
      pdf.line(margin, yPosition + 2, margin + tableWidth, yPosition + 2);
      
      // Store positions for drawing grid lines later
      const tableStartY = yPosition - 5;
      let tableEndY = yPosition + 2;
      const rowPositions = [tableStartY, yPosition + 2];
      
      // Move to first data row
      yPosition += 10;
      
      timelineParticipants.forEach((participant, participantIndex) => {
        // Check if we need a new page
        if (yPosition > pageHeight - (footerMargin + footerHeight + 15)) {
          // Draw all vertical lines for the current page
          for (let i = 0; i <= columns.length; i++) {
            const lineX = margin + (i * (tableWidth / columns.length));
            pdf.line(lineX, tableStartY, lineX, tableEndY);
          }
          
          addNewPage();
          
          // Restart table on new page
          pdf.setFontSize(9);
          pdf.setFont("helvetica", "bold");
          pdf.setTextColor(0, 0, 0);
          
          // Draw header row on new page
          xPos = margin + cellPadding;
          columns.forEach((col, index) => {
            const headerWidth = colWidths[index] - (cellPadding * 2);
            const textWidth = pdf.getStringUnitWidth(col) * pdf.getFontSize() / pdf.internal.scaleFactor;
            const textX = xPos + (headerWidth - textWidth) / 2;
            
            pdf.text(col, textX, yPosition);
            xPos += colWidths[index];
          });
          
          // Draw header row lines
          pdf.line(margin, yPosition - 5, margin + tableWidth, yPosition - 5);
          pdf.line(margin, yPosition + 2, margin + tableWidth, yPosition + 2);
          
          // Update table tracking variables
          tableEndY = yPosition + 2;
          rowPositions.length = 0;
          rowPositions.push(yPosition - 5, yPosition + 2);
          
          // Move to first data row on new page
          yPosition += 10;
        }
        
        // Store initial Y position for this row
        const rowStartY = yPosition - 5;
        let rowHeight = 0;
        
        // Add participant data
        xPos = margin + cellPadding; // Add padding from left
        
        // Set font to normal for participant data (not bold)
        pdf.setFont("helvetica", "normal");
        pdf.setTextColor(0, 0, 0);
        
        // Participant name (vendor name)
        const participantName = participant.name || "";
        
        // Calculate base Y position for this row (centered vertically in the cell)
        const baseYPos = rowStartY + cellPadding + 3; // Reduced from +5 to +3
        
        // Add participant name
        pdf.text(participantName, xPos, baseYPos);
        let cellHeight = 5;
        
        // Add vendor type on next line if enabled
        if (participant.type && exportOptions.showVendorTypes) {
          pdf.setFontSize(7); // Even smaller font for vendor type
          pdf.setTextColor(100, 100, 100);
          pdf.text(participant.type.name, xPos, baseYPos + 5);
          pdf.setFontSize(9); // Reset font size
          pdf.setTextColor(0, 0, 0);
          cellHeight += 5; // Add height for the vendor type
        }
        
        // Track maximum cell height
        rowHeight = Math.max(rowHeight, cellHeight);
        
        // Move to next column
        xPos = margin + colWidths[0] + cellPadding;
        
        // Contact name (if enabled)
        if (exportOptions.showContactName) {
          // Split text if needed
          const contactName = participant.contactName || "";
          if (contactName) {
            const contactNameLines = pdf.splitTextToSize(contactName, colWidths[1] - (cellPadding * 2));
            pdf.text(contactNameLines, xPos, baseYPos);
            const contactHeight = contactNameLines.length * 5;
            rowHeight = Math.max(rowHeight, contactHeight);
          }
          xPos += colWidths[1];
        }
        
        // Email (if enabled)
        if (exportOptions.showEmail) {
          const email = participant.email || "";
          if (email) {
            const emailLines = pdf.splitTextToSize(email, colWidths[exportOptions.showContactName ? 2 : 1] - (cellPadding * 2));
            pdf.text(emailLines, xPos, baseYPos);
            const emailHeight = emailLines.length * 5;
            rowHeight = Math.max(rowHeight, emailHeight);
          }
          xPos += colWidths[exportOptions.showContactName ? 2 : 1];
        }
        
        // Phone (if enabled)
        if (exportOptions.showPhone) {
          const phone = participant.phone || "";
          if (phone) {
            const phoneLines = pdf.splitTextToSize(phone, colWidths[
              (exportOptions.showContactName ? 1 : 0) + 
              (exportOptions.showEmail ? 1 : 0) + 
              1
            ] - (cellPadding * 2));
            pdf.text(phoneLines, xPos, baseYPos);
            const phoneHeight = phoneLines.length * 5;
            rowHeight = Math.max(rowHeight, phoneHeight);
          }
          xPos += colWidths[
            (exportOptions.showContactName ? 1 : 0) + 
            (exportOptions.showEmail ? 1 : 0) + 
            1
          ];
        }
        
        // Address (if enabled)
        if (exportOptions.showAddress) {
          const address = participant.address || "";
          if (address) {
            const addressLines = pdf.splitTextToSize(address, colWidths[
              (exportOptions.showContactName ? 1 : 0) + 
              (exportOptions.showEmail ? 1 : 0) + 
              (exportOptions.showPhone ? 1 : 0) + 
              1
            ] - (cellPadding * 2));
            pdf.text(addressLines, xPos, baseYPos);
            const addressHeight = addressLines.length * 5;
            rowHeight = Math.max(rowHeight, addressHeight);
          }
          xPos += colWidths[
            (exportOptions.showContactName ? 1 : 0) + 
            (exportOptions.showEmail ? 1 : 0) + 
            (exportOptions.showPhone ? 1 : 0) + 
            1
          ];
        }
          
        // Notes (if enabled)
        if (exportOptions.showNotes) {
          const notes = participant.notes || "";
          if (notes) {
            const notesLines = pdf.splitTextToSize(notes, colWidths[
              (exportOptions.showContactName ? 1 : 0) + 
              (exportOptions.showEmail ? 1 : 0) + 
              (exportOptions.showPhone ? 1 : 0) + 
              (exportOptions.showAddress ? 1 : 0) + 
              1
            ] - (cellPadding * 2));
            pdf.text(notesLines, xPos, baseYPos);
            const notesHeight = notesLines.length * 5;
            rowHeight = Math.max(rowHeight, notesHeight);
          }
        }
        
        // Calculate final row height with padding
        rowHeight = Math.max(rowHeight, 5) + (cellPadding * 2);
        
        // Update table end position
        tableEndY = rowStartY + rowHeight;
        
        // Store the position for the next row
        rowPositions.push(tableEndY);
        
        // Move to next row
        yPosition = rowStartY + rowHeight + 5;
      });
      
      // Draw all vertical lines for the entire table at once
      for (let i = 0; i <= columns.length; i++) {
        const lineX = margin + (i * (tableWidth / columns.length));
        // Draw the vertical line from the top of the table to the bottom
        pdf.line(lineX, tableStartY, lineX, tableEndY);
      }
      
      // Draw all horizontal lines for rows using stored positions
      rowPositions.forEach(position => {
        // Draw the horizontal line from the left edge to the right edge of the table
        pdf.line(margin, position, margin + tableWidth, position);
      });
      
      yPosition = tableEndY + 10;
    }

    // Add Timeline heading above the timeline items
    // Check if there's enough space for the heading plus at least one timeline item
    // A typical timeline item needs about 30-40 points of vertical space
    if (yPosition > pageHeight - (footerMargin + footerHeight + 60)) {
      addNewPage();
    }
    
    // Mark the position before adding the Timeline heading
    const timelineHeadingPosition = yPosition;
    
    pdf.setFontSize(14);
    pdf.setTextColor(0, 0, 0);
    pdf.setFont("helvetica", "bold");
    pdf.text("Timeline", pdfWidth / 2, yPosition, {
      align: "center",
    });
    yPosition += 15;

    // Add items
    let currentCategory = "";

    itemsWithVendors.forEach((item, index) => {
      // Debug each item
      console.log(`PDF: Processing item ${item.id}:`, item);
      console.log(`PDF: Item has vendors?`, Boolean((item as any).vendors && Array.isArray((item as any).vendors) && (item as any).vendors.length > 0));
      
      // Check if we need a new page
      if (yPosition > pageHeight - (footerMargin + footerHeight)) {
        addNewPage();
        
        // If this is the first item, redraw the Timeline heading on the new page
        if (index === 0) {
          pdf.setFontSize(14);
          pdf.setTextColor(0, 0, 0);
          pdf.setFont("helvetica", "bold");
          pdf.text("Timeline", pdfWidth / 2, yPosition, {
            align: "center",
          });
          yPosition += 15;
        }
      }

      if (
        exportOptions.showCategories &&
        localShowCategories &&
        item.category &&
        item.category !== currentCategory
      ) {
        currentCategory = item.category;
        if (yPosition > pageHeight - (footerMargin + footerHeight + 20)) {
          addNewPage();
        }
        pdf.setFont("helvetica", "bold");
        pdf.setFontSize(12);
        pdf.setTextColor(0, 0, 0);
        pdf.text(currentCategory, margin, yPosition);
        yPosition += 14;
      }

      const timeWidth = exportOptions.showEndTimes ? 35 : 25;
      const contentStartX = margin + timeWidth + 5;

      // Time
      pdf.setFont("helvetica", "bold");
      pdf.setTextColor(0, 0, 0);
      pdf.setFontSize(11);
      if (exportOptions.showEndTimes) {
        const endTime = calculateEndTime(item.startTime, item.duration);
        pdf.text(`${item.startTime} - ${endTime}`, margin, yPosition);
      } else {
        pdf.text(item.startTime, margin, yPosition);
      }

      // Duration - removed as it's now included with the title
      
      // Title
      pdf.setTextColor(0, 0, 0);
      pdf.setFont("helvetica", "bold");
      pdf.setFontSize(11);
      
      // Handle multi-line titles
      const titleText = exportOptions.showDurations 
        ? `${item.title} (${item.duration} minutes)`
        : item.title;
        
      const titleLines = pdf.splitTextToSize(
        titleText,
        pdfWidth - contentStartX - margin
      );
      pdf.text(titleLines, contentStartX, yPosition);
      yPosition += 7 + (titleLines.length - 1) * 5;

      // Description
      if (exportOptions.showDescriptions && item.description) {
        pdf.setFont("helvetica", "normal");
        pdf.setFontSize(9);
        const descriptionLines = pdf.splitTextToSize(
          item.description,
          pdfWidth - contentStartX - margin,
        );
        pdf.text(descriptionLines, contentStartX, yPosition);
        yPosition += 5 * descriptionLines.length;
      }

      // Item participants if enabled
      if (exportOptions.showParticipants && (item as any).vendors && Array.isArray((item as any).vendors) && (item as any).vendors.length > 0) {
        // For debugging
        console.log("Item has vendors:", item.id, (item as any).vendors);
        pdf.setFont("helvetica", "normal");
        const participantsText = (item as any).vendors.map((vendor: any) => {
          const vendorName = vendor.vendor?.name || vendor.name || "Unnamed";
          const vendorType = vendor.vendor?.type?.name || vendor.type?.name || "";
          return vendorName + (exportOptions.showVendorTypes && vendorType ? ` (${vendorType})` : "");
        }).join(", ");
        
        // Add "Participants:" label in bold
        pdf.setFont("helvetica", "bold");
        pdf.text("Participants:", contentStartX, yPosition);
        yPosition += 5;
        
        // Add the actual participants list in normal font
        pdf.setFont("helvetica", "normal");
        const participantLines = pdf.splitTextToSize(
          participantsText,
          pdfWidth - (margin * 2) - 40
        );
        
        pdf.text(participantLines, contentStartX, yPosition);
        yPosition += participantLines.length * 5;
      }

      // Location - now in italic
      if (exportOptions.showLocations && item.location) {
        pdf.setFontSize(9);
        pdf.setTextColor(100, 100, 100);
        pdf.setFont("helvetica", "italic"); // Changed to italic
        
        // Handle multi-line locations
        const locationLines = pdf.splitTextToSize(
          `Location: ${item.location}`,
          pdfWidth - contentStartX - margin
        );
        pdf.text(locationLines, contentStartX, yPosition);
        yPosition += 5 * locationLines.length;
      }
      
      

      yPosition += 5; // Add space between items
    });

    if (
      exportOptions.includeImages &&
      timelineImages &&
      timelineImages.length > 0
    ) {
      console.log("Starting image export process for PDF");
      try {
        addNewPage();
        pdf.setFontSize(18);
        pdf.setFont("helvetica", "bold");
        pdf.text("Timeline Images", pdfWidth / 2, yPosition, {
          align: "center",
        });
        yPosition += 15;
        console.log("Processing images for PDF:", timelineImages.length);
        const maxImageWidth = pdfWidth - margin * 2;
        const imageSpacing = 25;
        
        for (let i = 0; i < timelineImages.length; i++) {
          try {
            let imageUrl = timelineImages[i].imageUrl;
            if (imageUrl.startsWith("/uploads/")) {
              imageUrl = window.location.origin + imageUrl;
            }
            console.log("Processing PDF image from URL:", imageUrl);
            
            // Create a new image element
            const img = new Image();
            img.crossOrigin = "Anonymous";
            
            // Use a promise to handle image loading
            await new Promise((resolve, reject) => {
              // Set up event handlers before setting src
              img.onload = () => {
                try {
                  console.log(`Image ${i} loaded successfully, dimensions: ${img.width}x${img.height}`);
                  const aspectRatio = img.width / img.height;
                  let imageWidth = maxImageWidth;
                  let imageHeight = imageWidth / aspectRatio;
                  
                  // Check if we need a new page
                  if (yPosition + imageHeight + 20 > pageHeight - margin) {
                    addNewPage();
                    yPosition = margin;
                  }
                  
                  // Add caption if available
                  if (timelineImages[i].caption) {
                    pdf.setFontSize(14);
                    pdf.setFont("helvetica", "bold");
                    pdf.text(
                      timelineImages[i].caption || "",
                      pdfWidth / 2,
                      yPosition,
                      { align: "center", maxWidth: maxImageWidth },
                    );
                    yPosition += 10; // Increased spacing after caption
                  }
                  
                  // Create a canvas to draw the image
                  const canvas = document.createElement("canvas");
                  canvas.width = img.width;
                  canvas.height = img.height;
                  const ctx = canvas.getContext("2d");
                  
                  if (!ctx) {
                    throw new Error("Failed to get canvas context");
                  }
                  
                  // Draw the image to canvas
                  ctx.drawImage(img, 0, 0);
                  
                  // Convert to data URL and add to PDF
                  const imgData = canvas.toDataURL("image/jpeg", 0.95);
                  pdf.addImage(
                    imgData,
                    "JPEG",
                    margin,
                    yPosition,
                    imageWidth,
                    imageHeight,
                  );
                  
                  // Update position for next item
                  yPosition += imageHeight + imageSpacing;
                  
                  resolve(true);
                } catch (err) {
                  console.error(`Error drawing image ${i} to canvas:`, err);
                  reject(err);
                }
              };
              
              img.onerror = (err) => {
                console.error(`Error loading image ${i}:`, err);
                reject(err);
              };
              
              // Set the source after event handlers are defined
              img.src = imageUrl;
              
              // Add a timeout to prevent hanging on image load
              setTimeout(() => {
                if (!img.complete) {
                  reject(new Error(`Image load timed out for ${imageUrl}`));
                }
              }, 10000); // 10 second timeout
            }).catch(err => {
              console.error(`Failed to load image ${i}:`, err);
              
              // Add error text to PDF
              pdf.setFontSize(12);
              pdf.setTextColor(255, 0, 0);
              pdf.text(`[Image ${i+1} could not be loaded]`, pdfWidth / 2, yPosition, {
                align: "center",
              });
              yPosition += 15;
            });
          } catch (error) {
            console.error(`Error processing image ${i} for PDF:`, error);
            continue;
          }
        }
      } catch (error) {
        console.error("Error in PDF image processing:", error);
        toast({
          title: "Warning",
          description: "Some images could not be included in the export",
          variant: "destructive",
        });
      }
    } else {
      console.log("Image export conditions not met for PDF:", {
        includeImages: exportOptions.includeImages,
        hasTimelineImages: !!timelineImages,
        timelineImagesLength: timelineImages?.length,
      });
    }
    
    // Add footer to the last page
    addFooter(pageNumber);

    pdf.save(`${getFormattedFilename()}.pdf`);
  };

  const exportToWord = async () => {
    // Debug timelineImages
    console.log("Word Export - timelineImages:", timelineImages);
    console.log("Word Export - exportOptions:", exportOptions);
    
    // Fetch participants if needed
    if (exportOptions.showParticipants && timelineParticipants.length === 0) {
      await fetchTimelineParticipants();
    }
    
    console.log('Export options (Word):', exportOptions);
    console.log('Timeline participants (Word):', timelineParticipants);
    
    const paragraphs = [];
    const timelineparagraphs = [];
    const participantsparagraphs = [];
    const detailsparagraphs = [];
    const imagesparagraphs = [];
    const tables = [];

    // Title section
    const titleText = (weddingInfo as any).title || `${weddingInfo.type || "Event"} Timeline`;
    paragraphs.push(
      new Paragraph({
        text: titleText,
        heading: HeadingLevel.HEADING_1,
        alignment: AlignmentType.CENTER,
        spacing: { after: 200 },
      })
    );

    // Add names if available
    if (weddingInfo.names) {
      paragraphs.push(
        new Paragraph({
          text: weddingInfo.names,
          alignment: AlignmentType.CENTER,
          spacing: { after: 200 },
        })
      );
    }

    // Add date if available
    if (weddingInfo.date) {
      paragraphs.push(
        new Paragraph({
          text: format(new Date(weddingInfo.date), "MMMM d, yyyy"),
          alignment: AlignmentType.CENTER,
          spacing: { after: 400 },
        })
      );
    }

    // Add location if available
    if (weddingInfo.location) {
      paragraphs.push(
        new Paragraph({
          text: `Location: ${weddingInfo.location}`,
          alignment: AlignmentType.CENTER,
          spacing: { after: 400 },
        })
      );
    }

    // Add timeline details (custom fields) if available
    const eventType = reduxEventTypes.find((et) => et.type === weddingInfo.type);
    if (exportOptions.showAdditionalDetails && eventType?.customFields && eventType.customFields.length > 0) {
      detailsparagraphs.push(
        new Paragraph({
          text: "Timeline Details",
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 400, after: 200 },
        })
      );

      eventType.customFields.forEach(field => {
        const fieldValue = weddingInfo.customFieldValues?.[field.id] ?? field.defaultValue ?? "";
        if (fieldValue) {
          detailsparagraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: `${field.name}: `,
                  bold: true,
                }),
                new TextRun({
                  text: String(fieldValue),
                }),
              ],
              spacing: { after: 120 },
            })
          );
        }
      });
    }

    // Add participants section if needed
    if (exportOptions.showParticipants && timelineParticipants.length > 0) {
      participantsparagraphs.push(
        new Paragraph({
          text: "Participants",
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 400, after: 200 },
        })
      );

      // Create a table for participants
      const participantsTable = new Table({
        width: {
          size: 100,
          type: WidthType.PERCENTAGE,
        },
        borders: {
          top: { style: BorderStyle.SINGLE, size: 1, color: "auto" },
          bottom: { style: BorderStyle.SINGLE, size: 1, color: "auto" },
          left: { style: BorderStyle.SINGLE, size: 1, color: "auto" },
          right: { style: BorderStyle.SINGLE, size: 1, color: "auto" },
          insideHorizontal: { style: BorderStyle.SINGLE, size: 1, color: "auto" },
          insideVertical: { style: BorderStyle.SINGLE, size: 1, color: "auto" },
        },
        rows: [
          // Header row
          new TableRow({
            tableHeader: true,
            height: { value: 400, rule: HeightRule.ATLEAST },
            cantSplit: true,
            children: [
              new TableCell({
                children: [
                  new Paragraph({
                    children: [
                      new TextRun({
                        text: "Participant",
                        bold: true,
                      }),
                    ],
                    spacing: { before: 120, after: 120 },
                  }),
                ],
                width: { size: 20, type: WidthType.PERCENTAGE },
                shading: { fill: "F2F2F2" },
                margins: {
                  top: 120,
                  bottom: 120,
                  left: 120,
                  right: 120,
                },
              }),
              ...(exportOptions.showContactName ? [
                new TableCell({
                  children: [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: "Contact Name",
                          bold: true,
                        }),
                      ],
                      spacing: { before: 120, after: 120 },
                    }),
                  ],
                  width: { size: 20, type: WidthType.PERCENTAGE },
                  shading: { fill: "F2F2F2" },
                  margins: {
                    top: 120,
                    bottom: 120,
                    left: 120,
                    right: 120,
                  },
                })
              ] : []),
              ...(exportOptions.showEmail ? [
                new TableCell({
                  children: [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: "Email",
                          bold: true,
                        }),
                      ],
                      spacing: { before: 120, after: 120 },
                    }),
                  ],
                  width: { size: 20, type: WidthType.PERCENTAGE },
                  shading: { fill: "F2F2F2" },
                  margins: {
                    top: 120,
                    bottom: 120,
                    left: 120,
                    right: 120,
                  },
                })
              ] : []),
              ...(exportOptions.showPhone ? [
                new TableCell({
                  children: [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: "Phone",
                          bold: true,
                        }),
                      ],
                      spacing: { before: 120, after: 120 },
                    }),
                  ],
                  width: { size: 20, type: WidthType.PERCENTAGE },
                  shading: { fill: "F2F2F2" },
                  margins: {
                    top: 120,
                    bottom: 120,
                    left: 120,
                    right: 120,
                  },
                })
              ] : []),
              ...(exportOptions.showAddress ? [
                new TableCell({
                  children: [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: "Address",
                          bold: true,
                        }),
                      ],
                      spacing: { before: 120, after: 120 },
                    }),
                  ],
                  width: { size: 20, type: WidthType.PERCENTAGE },
                  shading: { fill: "F2F2F2" },
                  margins: {
                    top: 120,
                    bottom: 120,
                    left: 120,
                    right: 120,
                  },
                })
              ] : []),
              ...(exportOptions.showNotes ? [
                new TableCell({
                  children: [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: "Notes",
                          bold: true,
                        }),
                      ],
                      spacing: { before: 120, after: 120 },
                    }),
                  ],
                  width: { size: 20, type: WidthType.PERCENTAGE },
                  shading: { fill: "F2F2F2" },
                  margins: {
                    top: 120,
                    bottom: 120,
                    left: 120,
                    right: 120,
                  },
                })
              ] : []),
            ],
          }),
          // Data rows
          ...timelineParticipants.map(participant => 
            new TableRow({
              cantSplit: true,
              children: [
                new TableCell({
                  children: [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: participant.name,
                          ...(participant.type && exportOptions.showVendorTypes ? { bold: true } : {}),
                        }),
                        ...(participant.type && exportOptions.showVendorTypes ? [
                          new TextRun({
                            text: ` ${participant.type.name}`,
                            italics: true,
                            color: "666666",
                          }),
                        ] : []),
                      ],
                      spacing: { before: 120, after: 120 },
                    }),
                  ],
                  margins: {
                    top: 120,
                    bottom: 120,
                    left: 120,
                    right: 120,
                  },
                }),
                ...(exportOptions.showContactName ? [
                  new TableCell({
                    children: [
                      new Paragraph({
                        text: participant.contactName || "",
                        spacing: { before: 120, after: 120 },
                      }),
                    ],
                    margins: {
                      top: 120,
                      bottom: 120,
                      left: 120,
                      right: 120,
                    },
                  })
                ] : []),
                ...(exportOptions.showEmail ? [
                  new TableCell({
                    children: [
                      new Paragraph({
                        text: participant.email || "",
                        spacing: { before: 120, after: 120 },
                      }),
                    ],
                    margins: {
                      top: 120,
                      bottom: 120,
                      left: 120,
                      right: 120,
                    },
                  })
                ] : []),
                ...(exportOptions.showPhone ? [
                  new TableCell({
                    children: [
                      new Paragraph({
                        text: participant.phone || "",
                        spacing: { before: 120, after: 120 },
                      }),
                    ],
                    margins: {
                      top: 120,
                      bottom: 120,
                      left: 120,
                      right: 120,
                    },
                  })
                ] : []),
                ...(exportOptions.showAddress ? [
                  new TableCell({
                    children: [
                      new Paragraph({
                        text: participant.address || "",
                        spacing: { before: 120, after: 120 },
                      }),
                    ],
                    margins: {
                      top: 120,
                      bottom: 120,
                      left: 120,
                      right: 120,
                    },
                  })
                ] : []),
                ...(exportOptions.showNotes ? [
                  new TableCell({
                    children: [
                      new Paragraph({
                        text: participant.notes || "",
                        spacing: { before: 120, after: 120 },
                      }),
                    ],
                    margins: {
                      top: 120,
                      bottom: 120,
                      left: 120,
                      right: 120,
                    },
                  })
                ] : []),
              ],
            })
          ),
        ],
      });

      tables.push(participantsTable);
    }

    // Add Timeline heading
    timelineparagraphs.push(
      new Paragraph({
        text: "Timeline",
        heading: HeadingLevel.HEADING_2,
        spacing: { before: 400, after: 200 },
      })
    );

    const items = isTemplate && propItems ? propItems : timelineItems;
    let sortedItems = [...items].sort((a, b) =>
      a.startTime.localeCompare(b.startTime),
    );

    // Fetch vendors for items if needed
    if (exportOptions.showParticipants) {
      sortedItems = await Promise.all(
        sortedItems.map(async (item) => {
          if (item.id) {
            try {
              const response = await fetch(`/api/timeline-events/${item.id}/vendors`);
              if (response.ok) {
                const vendors = await response.json();
                return { ...item, vendors };
              }
            } catch (error) {
              console.error("Error fetching vendors for item:", error);
            }
          }
          return item;
        })
      );
    }

    // Group items by category if needed
    const itemsByCategory = exportOptions.showCategories
      ? sortedItems.reduce((acc: { [key: string]: TimelineItem[] }, item) => {
          const category = item.category || "Uncategorized";
          if (!acc[category]) {
            acc[category] = [];
          }
          acc[category].push(item);
          return acc;
        }, {})
      : { "All Events": sortedItems };

    let currentCategory = "";

    // Process each category
    for (const [category, categoryItems] of Object.entries(itemsByCategory)) {
      // Add category header if showing categories
      if (exportOptions.showCategories) {
        timelineparagraphs.push(
          new Paragraph({
            text: category,
            heading: HeadingLevel.HEADING_3,
            spacing: { before: 300, after: 200 },
          })
        );
      }

      // Process each item in the category
      categoryItems.forEach((item) => {
        // Time and title paragraph
        const timeText = exportOptions.showEndTimes
          ? `${item.startTime} - ${item.endTime}`
          : item.startTime;
        
        const titleWithDuration = exportOptions.showDurations
          ? `${item.title} (${item.duration} minutes)`
          : item.title;
        
        timelineparagraphs.push(
          new Paragraph({
            children: [
              new TextRun({
                text: timeText,
                bold: true,
              }),
              new TextRun({
                text: "\t",  // Tab character
                bold: true,
              }),
              new TextRun({
                text: titleWithDuration,
                bold: true,
              }),
            ],
            spacing: { before: 200, after: 100 },
            keepNext: true, // Keep with next paragraph
          }),
        );

        // Description paragraph
        if (exportOptions.showDescriptions && item.description) {
          timelineparagraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: item.description,
                }),
              ],
              spacing: { line: 360 },
              keepNext: Boolean(exportOptions.showLocations && item.location), // Explicitly convert to boolean
              keepLines: true, // Keep all lines of this paragraph together
            }),
          );
        }
        
        // Location paragraph
        if (exportOptions.showLocations && item.location) {
          timelineparagraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: "Location: ",
                  color: "666666",
                  italics: true,
                  bold: true,
                }),
                new TextRun({
                  text: item.location,
                  color: "666666",
                  italics: true,
                }),
              ],
              spacing: { line: 360, after: exportOptions.showParticipants ? 0 : 240 },
              keepLines: true, // Keep all lines of this paragraph together
            }),
          );
        }
        
        // Item participants paragraph
        if (exportOptions.showParticipants && 'vendors' in item && Array.isArray((item as any).vendors) && (item as any).vendors.length > 0) {
          const participantsText = (item as any).vendors.map((vendor: any) => {
            const vendorName = vendor.vendor?.name || vendor.name || "Unnamed";
            const vendorType = vendor.vendor?.type?.name || vendor.type?.name || "";
            return vendorName + (vendorType && exportOptions.showVendorTypes ? ` (${vendorType})` : "");
          }).join(", ");
          
          timelineparagraphs.push(
            new Paragraph({
              children: [
                new TextRun({
                  text: "Participants: ",
                  color: "666666",
                  italics: true,
                  bold: true,
                }),
                new TextRun({
                  text: participantsText,
                  color: "666666",
                  italics: true,
                }),
              ],
              spacing: { line: 360, after: 240 },
              keepLines: true, // Keep all lines of this paragraph together
            }),
          );
        }
      });
    }

    // Add images section if needed
    if (exportOptions.includeImages && timelineImages && timelineImages.length > 0) {
      imagesparagraphs.push(
        new Paragraph({
          text: "Timeline Images",
          heading: HeadingLevel.HEADING_2,
          spacing: { before: 400, after: 200 },
        })
      );

      // Process each image
      for (const image of timelineImages) {
        try {
          // Add image caption if available
          if (image.caption) {
            imagesparagraphs.push(
              new Paragraph({
                text: image.caption,
                spacing: { before: 200, after: 100 },
              })
            );
          }

          // Attempt to fetch and add the actual image
          try {
            let imageUrl = image.imageUrl;
            if (imageUrl.startsWith("/uploads/")) {
              imageUrl = window.location.origin + imageUrl;
            }
            
            console.log("Fetching image for Word export:", imageUrl);
            
            // Use fetch to get the image data
            const response = await fetch(imageUrl);
            if (!response.ok) {
              throw new Error(`Failed to fetch image: ${response.statusText}`);
            }
            
            const blob = await response.blob();
            const arrayBuffer = await blob.arrayBuffer();
            const uint8Array = new Uint8Array(arrayBuffer);
            
            // Create an image run with the fetched data
            const imageRun = new ImageRun({
              data: uint8Array,
              transformation: {
                width: 400,
                height: 300,
              },
              type: "png",
              fallback: {
                data: uint8Array,
                type: "png",
              }
            });
            
            // Add the image to the document
            imagesparagraphs.push(
              new Paragraph({
                children: [imageRun],
                alignment: AlignmentType.CENTER,
                spacing: { after: 240 },
              })
            );
            
            console.log("Successfully added image to Word document");
          } catch (imageError) {
            console.error("Error adding image to Word document:", imageError);
            // Fallback to placeholder text if image loading fails
            imagesparagraphs.push(
              new Paragraph({
                children: [
                  new TextRun({
                    text: "[Image could not be loaded]",
                    italics: true,
                    color: "FF0000",
                  }),
                ],
                spacing: { after: 240 },
              })
            );
          }
        } catch (error) {
          console.error("Error processing image for Word document:", error);
        }
      }
    }

    // Add all paragraphs to the document
    const doc = new Document({
      sections: [
        {
          properties: {},
          children: [
            ...paragraphs,
            ...detailsparagraphs,
            ...participantsparagraphs,
            ...(tables.length > 0 ? tables : []),
            ...timelineparagraphs,
            ...imagesparagraphs,
          ],
          footers: {
            default: new Footer({
              children: [
                new Paragraph({
                  alignment: AlignmentType.CENTER,
                  children: [
                    new TextRun({
                      text: "Page ",
                      size: 20,
                    }),
                    new TextRun({
                      children: [PageNumber.CURRENT],
                      size: 20,
                    }),
                    new TextRun({
                      text: " of ",
                      size: 20,
                    }),
                    new TextRun({
                      children: [PageNumber.TOTAL_PAGES],
                      size: 20,
                    }),
                  ],
                }),
                ...(exportOptions.includeUserInfo && exportFooterText ? [
                  new Paragraph({
                    alignment: AlignmentType.CENTER,
                    children: [
                      new TextRun({
                        text: exportFooterText,
                        size: 16,
                        color: "808080",
                      }),
                    ],
                  }),
                ] : []),
              ],
            }),
          },
        },
      ],
    });

    // Generate and save the document
    try {
      // Create a blob from the document
      const blob = await Packer.toBlob(doc);
      
      // Create a download link
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `${getFormattedFilename()}.docx`;
      
      // Trigger the download
      document.body.appendChild(a);
      a.click();
      
      // Clean up
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      console.log("Word document created successfully");
      toast({
        title: "Success",
        description: "Word document created successfully",
        variant: "default",
      });
    } catch (error) {
      console.error("Error generating Word document:", error);
      toast({
        title: "Error",
        description: "Failed to generate Word document",
        variant: "destructive",
      });
    }
  };

  // Function to generate a formatted filename for exports
  const getFormattedFilename = () => {
    const baseName = weddingInfo.names
      ? `${weddingInfo.names} Timeline`
      : `${weddingInfo.type || "Event"} Timeline`;

    const datePart = weddingInfo.date
      ? ` - ${format(new Date(weddingInfo.date), "d MMMM yyyy")}`
      : "";

    return `${baseName}${datePart}`;
  };

  // Function to fetch timeline participants
  const fetchTimelineParticipants = async () => {
    if (!timelineId) return;
    
    try {
      const response = await fetch(`/api/timelines/${timelineId}/vendors`);
      if (!response.ok) {
        throw new Error('Failed to fetch timeline participants');
      }
      
      const data = await response.json();
      console.log('Fetched timeline participants:', data);
      
      // Process the data to ensure we have the right format with all fields
      const processedParticipants = Array.isArray(data) 
        ? data.map(item => {
            if (item.vendor) {
              return {
                id: item.vendor.id,
                name: item.vendor.name || 'Unnamed Vendor',
                contactName: item.vendor.contactName,
                email: item.vendor.email,
                phone: item.vendor.phone,
                address: item.vendor.address,
                notes: item.vendor.notes,
                type: item.vendor.type
              };
            }
            return {
              ...item,
              name: item.name || 'Unnamed Vendor'
            };
          })
        : [];
      
      setTimelineParticipants(processedParticipants);
    } catch (error) {
      console.error('Error fetching timeline participants:', error);
      toast({
        title: "Error",
        description: "Failed to fetch timeline participants for export",
        variant: "destructive",
      });
    }
  };

  // Function to handle opening the export dialog
  const handleOpenExportDialog = () => {
    // Add debugging for timelineImages
    console.log("Opening export dialog, timelineImages:", timelineImages);
    if (timelineImages && timelineImages.length > 0) {
      console.log("First image URL:", timelineImages[0].imageUrl);
    } else {
      console.log("No timeline images available");
    }
    
    setShowExportDialog(true);
  };

  // Add this function to the component
  const refreshTimelineItemVendors = () => {
    // Use setTimeout to ensure this runs after the current render cycle
    setTimeout(() => {
      // Refresh all timeline item participant selectors
      const timelineItems = document.querySelectorAll('.timeline-item');
      timelineItems.forEach(item => {
        const vendorSelector = item.querySelector('.vendor-section');
        if (vendorSelector) {
          // Force a re-render by adding and removing a class
          vendorSelector.classList.add('refreshing');
          setTimeout(() => {
            vendorSelector.classList.remove('refreshing');
          }, 100);
        }
      });
    }, 100);
  };

  const createPdf = async (items: TimelineItem[], weddingInfo: WeddingInfo) => {
    try {
      // Fetch vendors for items if needed
      let itemsWithVendors = [...items];
      if (exportOptions.showParticipants) {
        itemsWithVendors = await Promise.all(
          items.map(async (item) => {
            if (item.id) {
              try {
                const response = await fetch(`/api/timeline-events/${item.id}/vendors`);
                if (response.ok) {
                  const vendors = await response.json();
                  console.log(`Fetched vendors for item ${item.id}:`, vendors);
                  return { ...item, vendors };
                }
              } catch (error) {
                console.error("Error fetching vendors for item:", error);
              }
            }
            return item;
          })
        );
      }

      const doc = new jsPDF();
      let yPos = 20;
      const pageHeight = doc.internal.pageSize.height;
      const margin = 10;
      let currentPage = 1;

      // Set title
      doc.setFontSize(24);
      doc.text(weddingInfo.title || "Timeline", doc.internal.pageSize.width / 2, yPos, {
        align: "center",
      });
      yPos += 15;

      // Helper function to check if we need a new page
      const checkAndAddPage = (requiredSpace: number) => {
        if (yPos + requiredSpace > pageHeight - margin) {
          doc.addPage();
          currentPage++;
          yPos = 20;
          return true;
        }
        return false;
      };

      // Group items by category if needed
      const groupedItems = exportOptions.showCategories
        ? itemsWithVendors.reduce((acc: { [key: string]: TimelineItem[] }, item) => {
            const category = item.category || "Uncategorized";
            if (!acc[category]) {
              acc[category] = [];
            }
            acc[category].push(item);
            return acc;
          }, {})
        : { "All Events": itemsWithVendors };

      for (const [category, categoryItems] of Object.entries(groupedItems)) {
        // Add category header if showing categories
        if (exportOptions.showCategories) {
          checkAndAddPage(10);
          doc.setFontSize(16);
          doc.text(category, margin, yPos);
          yPos += 10;
        }

        // Process each item
        for (const item of categoryItems) {
          const itemHeight = 10 + (exportOptions.showDescriptions && item.description ? 5 : 0);
          checkAndAddPage(itemHeight);

          // Time and title
          doc.setFontSize(12);
          doc.setFont("helvetica", "bold");
          const timeText = exportOptions.showEndTimes
            ? `${item.startTime} - ${item.endTime}`
            : item.startTime;
          doc.text(`${timeText}: ${item.title}`, margin, yPos);
          yPos += 5;

          // Additional details
          doc.setFont("helvetica", "normal");
          doc.setFontSize(10);

          if (exportOptions.showDurations) {
            doc.text(`Duration: ${item.duration} minutes`, margin + 5, yPos);
            yPos += 5;
          }

          if (exportOptions.showLocations && item.location) {
            doc.text(`Location: ${item.location}`, margin + 5, yPos);
            yPos += 5;
          }

          if (exportOptions.showDescriptions && item.description) {
            doc.text(`Description: ${item.description}`, margin + 5, yPos);
            yPos += 5;
          }

          // Add vendor information
          if (exportOptions.showParticipants && 'vendors' in item && Array.isArray((item as any).vendors) && (item as any).vendors.length > 0) {
            const vendorsText = (item as any).vendors
              .map((v: any) => {
                const vendorName = v.vendor?.name || v.name || "Unnamed";
                const vendorType = v.vendor?.type?.name || v.type?.name || "";
                return vendorName + (vendorType && exportOptions.showVendorTypes ? ` (${vendorType})` : "");
              })
              .join(", ");
            
            const participantLines = pdf.splitTextToSize(
              `Participants: ${vendorsText}`,
              pdfWidth - (margin * 2) - 40
            );
            
            pdf.text(participantLines, margin + 5, yPos);
            yPos += participantLines.length * 5;
          }

          yPos += 5; // Add space between items
        }
      }

      // Save the PDF
      doc.save(`${getFormattedFilename()}.pdf`);
    } catch (error) {
      console.error("Error generating PDF:", error);
      toast({
        title: "Error",
        description: "Failed to generate PDF",
        variant: "destructive",
      });
    }
  };
  

  // Function to handle updating timeline items
  const handleUpdateItem = (id: string, updates: Partial<TimelineItem>) => {
    if (isTemplate && setTemplateItems && propItems) {
      const updatedItems = propItems.map((item) =>
        item.id === id ? { ...item, ...updates } : item,
      );
      setTemplateItems(updatedItems);
    } else {
      dispatch(updateItem({ id, updates }));
    }
  };
  
  // Function to handle deleting timeline items
  const handleDeleteItem = (id: string) => {
    if (onDeleteItem) {
      onDeleteItem(id);
    } else {
      dispatch(deleteItem(id));
    }
  };
  
  // Function to handle moving timeline items
  const handleMoveItem = (dragIndex: number, hoverIndex: number) => {
    dispatch(moveItem({ dragIndex, hoverIndex }));
  };
  
  // Function to handle category toggle
  const handleCategoryToggle = async (checked: boolean) => {
    setLocalShowCategories(checked);
    setShowCategories(checked);
  };
  
  // Function to handle time shift for bulk edit
  const handleTimeShift = (minutes: { minutes: number }) => {
    const selectedItemsCount = selectedItems.length;
    dispatch(adjustSelectedTimes(minutes));
    
    // Show toast notification
    const direction = minutes.minutes > 0 ? "later" : "earlier";
    const absoluteMinutes = Math.abs(minutes.minutes);
    toast({
      title: `Time Adjusted`,
      description: `${selectedItemsCount} item${selectedItemsCount !== 1 ? 's' : ''} moved ${absoluteMinutes} minute${absoluteMinutes !== 1 ? 's' : ''} ${direction}`,
      variant: "default",
    });
  };
  
  // Function to handle selecting all items in a category
  const handleSelectAllInCategory = (category: string) => {
    dispatch(selectAllInCategory(category));
  };
  
  // Function to handle clearing selection
  const handleClearSelection = () => {
    dispatch(clearSelection());
  };
  
  // Function to handle deleting selected items
  const handleDeleteSelected = () => {
    dispatch(deleteSelectedItems());
  };
  
  // Function to handle updating custom fields
  const handleUpdateCustomFields = (
    itemId: string,
    customFieldValues: Record<string, string | number | boolean | null>,
  ) => {
    if (isTemplate && propItems && setTemplateItems) {
      const updatedItems = [...propItems];
      const itemIndex = updatedItems.findIndex((item) => item.id === itemId);
      if (itemIndex !== -1) {
        updatedItems[itemIndex] = {
          ...updatedItems[itemIndex],
          customFieldValues,
        };
      }
      setTemplateItems(updatedItems);
    } else {
      // @ts-ignore - customFieldValues is used in the component but not in the Redux store
      dispatch(updateItem({ id: itemId, updates: { customFieldValues } }));
    }
  };

  // Export dialog UI
  const renderExportDialog = () => (
    <Dialog open={showExportDialog} onOpenChange={setShowExportDialog}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Export Timeline</DialogTitle>
          <DialogDescription>
            Choose your export options and format
          </DialogDescription>
        </DialogHeader>

        <div className="grid gap-6 py-4">
          {/* New General section at the top */}
          <div className="grid gap-4">
            <h3 className="font-medium text-purple-600">General</h3>
            <div className="grid grid-cols-2 gap-4">
              <div className="flex items-center space-x-2">
                <Switch
                  id="show-additional-details"
                  checked={exportOptions.showAdditionalDetails}
                  onCheckedChange={(checked) =>
                    setExportOptions({
                      ...exportOptions,
                      showAdditionalDetails: checked,
                    })
                  }
                  className="data-[state=checked]:bg-purple-600"
                />
                <Label htmlFor="show-additional-details" className="text-base font-medium">Show Additional Details</Label>
              </div>
              
              <div className="flex items-center space-x-2">
                <Switch
                  id="include-user-info"
                  checked={exportOptions.includeUserInfo}
                  onCheckedChange={(checked) =>
                    setExportOptions({
                      ...exportOptions,
                      includeUserInfo: checked,
                    })
                  }
                  className="data-[state=checked]:bg-purple-600"
                />
                <Label htmlFor="include-user-info" className="text-base font-medium">Include Footer</Label>
              </div>
            </div>
          </div>

          {!isTemplate && (
            <>
              {/* Participants section moved up */}
              <div className="grid gap-4">
                <h3 className="font-medium text-purple-600">Participants</h3>
                
                {/* Show Participants toggle on its own line */}
                <div className="flex items-center space-x-2">
                  <Switch
                    id="show-participants"
                    checked={exportOptions.showParticipants}
                    onCheckedChange={(checked) =>
                      setExportOptions({
                        ...exportOptions,
                        showParticipants: checked,
                      })
                    }
                    className="data-[state=checked]:bg-purple-600"
                  />
                  <Label htmlFor="show-participants" className="text-base font-medium">Show Participants Table</Label>
                </div>
                
                {/* Only show participant detail options if Show Participants is enabled */}
                {exportOptions.showParticipants && (
                  <div className="grid grid-cols-2 gap-4 pl-6 border-l-2 border-purple-100 dark:border-purple-900/30">
                    <div className="flex items-center space-x-2">
                      <Switch
                        id="show-contact-name"
                        checked={exportOptions.showContactName}
                        onCheckedChange={(checked) =>
                          setExportOptions({
                            ...exportOptions,
                            showContactName: checked,
                          })
                        }
                        className="data-[state=checked]:bg-purple-600"
                      />
                      <Label htmlFor="show-contact-name" className="text-base font-medium">Show Contact Name</Label>
                    </div>

                    <div className="flex items-center space-x-2">
                      <Switch
                        id="show-email"
                        checked={exportOptions.showEmail}
                        onCheckedChange={(checked) =>
                          setExportOptions({
                            ...exportOptions,
                            showEmail: checked,
                          })
                        }
                        className="data-[state=checked]:bg-purple-600"
                      />
                      <Label htmlFor="show-email" className="text-base font-medium">Show Email</Label>
                    </div>

                    <div className="flex items-center space-x-2">
                      <Switch
                        id="show-phone"
                        checked={exportOptions.showPhone}
                        onCheckedChange={(checked) =>
                          setExportOptions({
                            ...exportOptions,
                            showPhone: checked,
                          })
                        }
                        className="data-[state=checked]:bg-purple-600"
                      />
                      <Label htmlFor="show-phone" className="text-base font-medium">Show Phone</Label>
                    </div>
                    
                    <div className="flex items-center space-x-2">
                      <Switch
                        id="show-address"
                        checked={exportOptions.showAddress}
                        onCheckedChange={(checked) =>
                          setExportOptions({
                            ...exportOptions,
                            showAddress: checked,
                          })
                        }
                        className="data-[state=checked]:bg-purple-600"
                      />
                      <Label htmlFor="show-address" className="text-base font-medium">Show Address</Label>
                    </div>
                    
                    <div className="flex items-center space-x-2">
                      <Switch
                        id="show-notes"
                        checked={exportOptions.showNotes}
                        onCheckedChange={(checked) =>
                          setExportOptions({
                            ...exportOptions,
                            showNotes: checked,
                          })
                        }
                        className="data-[state=checked]:bg-purple-600"
                      />
                      <Label htmlFor="show-notes" className="text-base font-medium">Show Notes</Label>
                    </div>
                    
                    <div className="flex items-center space-x-2">
                      <Switch
                        id="show-vendor-types"
                        checked={exportOptions.showVendorTypes}
                        onCheckedChange={(checked) =>
                          setExportOptions({
                            ...exportOptions,
                            showVendorTypes: checked,
                          })
                        }
                        className="data-[state=checked]:bg-purple-600"
                      />
                      <Label htmlFor="show-vendor-types" className="text-base font-medium">Show Vendor Types</Label>
                    </div>
                  </div>
                )}
              </div>
            </>
          )}

          {/* Renamed from "Content Options" to "Items" */}
          <div className="grid gap-4">
            <h3 className="font-medium text-purple-600">Items</h3>
            <div className="grid grid-cols-2 gap-4">
              <div className="flex items-center space-x-2">
                <Switch
                  id="show-categories"
                  checked={exportOptions.showCategories}
                  onCheckedChange={(checked) =>
                    setExportOptions({
                      ...exportOptions,
                      showCategories: checked,
                    })
                  }
                  className="data-[state=checked]:bg-purple-600"
                />
                <Label htmlFor="show-categories" className="text-base font-medium">Show Categories</Label>
              </div>

              <div className="flex items-center space-x-2">
                <Switch
                  id="show-durations"
                  checked={exportOptions.showDurations}
                  onCheckedChange={(checked) =>
                    setExportOptions({
                      ...exportOptions,
                      showDurations: checked,
                    })
                  }
                  className="data-[state=checked]:bg-purple-600"
                />
                <Label htmlFor="show-durations" className="text-base font-medium">Show Durations</Label>
              </div>

              <div className="flex items-center space-x-2">
                <Switch
                  id="show-descriptions"
                  checked={exportOptions.showDescriptions}
                  onCheckedChange={(checked) =>
                    setExportOptions({
                      ...exportOptions,
                      showDescriptions: checked,
                    })
                  }
                  className="data-[state=checked]:bg-purple-600"
                />
                <Label htmlFor="show-descriptions" className="text-base font-medium">Show Descriptions</Label>
              </div>

              <div className="flex items-center space-x-2">
                <Switch
                  id="show-locations"
                  checked={exportOptions.showLocations}
                  onCheckedChange={(checked) =>
                    setExportOptions({
                      ...exportOptions,
                      showLocations: checked,
                    })
                  }
                  className="data-[state=checked]:bg-purple-600"
                />
                <Label htmlFor="show-locations" className="text-base font-medium">Show Locations</Label>
              </div>

              <div className="flex items-center space-x-2">
                <Switch
                  id="show-end-times"
                  checked={exportOptions.showEndTimes}
                  onCheckedChange={(checked) =>
                    setExportOptions({
                      ...exportOptions,
                      showEndTimes: checked,
                    })
                  }
                  className="data-[state=checked]:bg-purple-600"
                />
                <Label htmlFor="show-end-times" className="text-base font-medium">Show End Times</Label>
              </div>

              <div className="flex items-center space-x-2">
                <Switch
                  id="show-icons"
                  checked={exportOptions.showIcons}
                  onCheckedChange={(checked) =>
                    setExportOptions({
                      ...exportOptions,
                      showIcons: checked,
                    })
                  }
                  className="data-[state=checked]:bg-purple-600"
                />
                <Label htmlFor="show-icons" className="text-base font-medium">Show Icons</Label>
              </div>
              
              <div className="flex items-center space-x-2">
                <Switch
                  id="show-item-participants"
                  checked={exportOptions.showItemParticipants}
                  onCheckedChange={(checked) =>
                    setExportOptions({
                      ...exportOptions,
                      showItemParticipants: checked,
                    })
                  }
                  className="data-[state=checked]:bg-purple-600"
                />
                <Label htmlFor="show-item-participants" className="text-base font-medium">Show Participants</Label>
              </div>
            </div>
          </div>

          {!isTemplate && (
            <>
              {/* Images section remains last */}
              <div className="grid gap-4">
                <h3 className="font-medium text-purple-600">Images</h3>
                <div className="flex items-center space-x-2">
                  <Switch
                    id="include-images"
                    checked={exportOptions.includeImages}
                    onCheckedChange={(checked) =>
                      setExportOptions({
                        ...exportOptions,
                        includeImages: checked,
                      })
                    }
                    className="data-[state=checked]:bg-purple-600"
                  />
                  <Label htmlFor="include-images" className="text-base font-medium">Include Images</Label>
                </div>
              </div>
            </>
          )}

          <Tabs defaultValue="preview" className="w-full">
            <TabsList className="grid w-full grid-cols-2">
              <TabsTrigger value="preview" className="data-[state=active]:bg-purple-600 data-[state=active]:text-white">Preview (beta)</TabsTrigger>
              <TabsTrigger value="export" className="data-[state=active]:bg-purple-600 data-[state=active]:text-white">Export</TabsTrigger>
            </TabsList>
            <TabsContent value="preview" className="mt-4">
              <ScrollArea className="h-[300px] w-full rounded-md border p-4">
                <div 
                  className="prose prose-sm max-w-none dark:prose-invert" 
                  dangerouslySetInnerHTML={{ __html: previewContent }}
                />
              </ScrollArea>
            </TabsContent>
            <TabsContent value="export" className="mt-4">
              <div className="flex flex-row gap-4 justify-between">
                <Button
                  onClick={exportToCSV}
                  className="flex-1 bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white font-medium shadow-md"
                >
                  <FileText className="mr-2 h-4 w-4 text-white" />
                  Export to CSV
                </Button>
                <Button 
                  onClick={exportToPDF} 
                  className="flex-1 bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white font-medium shadow-md"
                >
                  <FileDown className="mr-2 h-4 w-4 text-white" />
                  Export to PDF
                </Button>
                <Button 
                  onClick={exportToWord} 
                  className="flex-1 bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-700 hover:to-indigo-700 text-white font-medium shadow-md"
                >
                  <FileDown className="mr-2 h-4 w-4 text-white" />
                  Export to Word
                </Button>
              </div>
            </TabsContent>
          </Tabs>
        </div>
      </DialogContent>
    </Dialog>
  );

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between mb-6">
        <div className="flex items-center gap-2">
          <h1 className="text-2xl font-semibold text-foreground">
            {weddingInfo.names || "Untitled Timeline"}
          </h1>
          {weddingInfo.date && (
            <span className="text-muted-foreground">
              • {format(new Date(weddingInfo.date), "EEE, d MMMM yyyy")}
            </span>
          )}
        </div>
        <div className="flex items-center gap-2">
          {!isTemplate && (
            <>
              <Button
                variant="outline"
                size="sm"
                onClick={() => setSaveTemplateDialogOpen(true)}
                className="bg-white dark:bg-slate-800"
              >
                <FileText className="w-4 h-4 mr-2 text-purple-600" />
                Templates
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => setShowExportDialog(true)}
                className="bg-white dark:bg-slate-800"
              >
                <Download className="w-4 h-4 mr-2 text-purple-600" />
                Export
              </Button>
            </>
          )}
          {isTemplate && (
            <Button
              variant="outline"
              size="sm"
              onClick={() => window.history.back()}
              className="bg-white dark:bg-slate-800"
            >
              <ArrowLeft className="w-4 h-4 mr-2 text-purple-600" />
              Back to Templates
            </Button>
          )}
        </div>
      </div>

      {!isTemplate && (
          <><div className="mt-4 border-t pt-4">
      </div>
          {/* Event Overview section with heading */}
          <div className="mb-6 bg-white dark:bg-slate-800 rounded-lg border shadow-sm overflow-hidden">
            <div 
              className="p-4 flex items-center justify-between cursor-pointer bg-gradient-to-r from-purple-50 to-indigo-50 dark:from-purple-900/20 dark:to-indigo-900/20 hover:from-purple-100 hover:to-indigo-100 dark:hover:from-purple-900/30 dark:hover:to-indigo-900/30 transition-colors"
              onClick={() => setShowTimelineInfo(!showTimelineInfo)}
            >
              <div className="flex items-center">
                <CalendarIcon className="h-5 w-5 mr-2 text-purple-600" />
                <h3 className="text-lg font-medium">Event Overview</h3>
              </div>
              <ChevronDown
                className={`h-5 w-5 text-purple-600 transition-transform ${
                  showTimelineInfo ? "transform rotate-180" : ""
                }`}
              />
            </div>
            
            {showTimelineInfo && (
              <div className="p-6 space-y-6">
                <div className="flex flex-col items-center gap-6">
                  <div className="w-full max-w-2xl">
                    <div className="relative">
                      <Input
                        type="text"
                        placeholder="Timeline Name"
                        value={weddingInfo.names || ""}
                        onChange={(e) =>
                          dispatch(
                            updateWeddingInfo({
                              names: e.target.value,
                              date: weddingInfo.date,
                              type: weddingInfo.type,
                              location: weddingInfo.location,
                              customFieldValues: weddingInfo.customFieldValues,
                            }),
                          )
                        }
                        className="text-xl text-center font-semibold pl-10 pr-10 h-12 bg-gray-50 dark:bg-slate-800 border-gray-200 dark:border-gray-700"
                      />
                      <FileText className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-purple-600" />
                    </div>
                  </div>

                  <div className="grid grid-cols-1 md:grid-cols-3 gap-4 w-full max-w-2xl">
                    <Popover>
                      <PopoverTrigger asChild>
                        <Button
                          variant="outline"
                          className="w-full h-12 text-left font-medium justify-start relative pl-10"
                        >
                          <CalendarIcon className="absolute left-3 h-5 w-5 text-purple-600" />
                          {weddingInfo.date ? (
                            format(new Date(weddingInfo.date), "EEE, d MMMM yyyy")
                          ) : (
                            <span className="text-muted-foreground">Pick a date</span>
                          )}
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0" align="start">
                        <Calendar
                          mode="single"
                          selected={weddingInfo.date ? new Date(weddingInfo.date) : undefined}
                          defaultMonth={weddingInfo.date ? new Date(weddingInfo.date) : undefined}
                          onSelect={(date) =>
                            dispatch(
                              updateWeddingInfo({
                                date: date ? format(date, "yyyy-MM-dd") : undefined,
                                names: weddingInfo.names,
                                type: weddingInfo.type,
                                location: weddingInfo.location,
                                customFieldValues: weddingInfo.customFieldValues,
                              }),
                            )
                          }
                          initialFocus
                          className="border-none"
                          classNames={{
                            day_selected: "bg-purple-600 text-white hover:bg-purple-700 hover:text-white focus:bg-purple-600 focus:text-white",
                            day_today: "bg-purple-100 text-purple-900",
                          }}
                        />
                      </PopoverContent>
                    </Popover>

                    <Select
                      value={weddingInfo.type || ""}
                      onValueChange={(value) =>
                        dispatch(
                          updateWeddingInfo({
                            type: value,
                            date: weddingInfo.date,
                            names: weddingInfo.names,
                            location: weddingInfo.location,
                            customFieldValues: weddingInfo.customFieldValues,
                          }),
                        )
                      }
                    >
                      <SelectTrigger className="h-12 pl-10 relative bg-gray-50 dark:bg-slate-800">
                        <List className="absolute left-3 h-5 w-5 text-purple-600" />
                        <SelectValue placeholder="Select event type" />
                      </SelectTrigger>
                      <SelectContent>
                        {reduxEventTypes.map((eventType: any) => (
                          <SelectItem
                            key={eventType.type}
                            value={eventType.type}
                            className="font-medium"
                          >
                            {eventType.type}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>

                    <div className="relative">
                      <Input
                        type="text"
                        placeholder="Location"
                        value={weddingInfo.location || ""}
                        onChange={(e) =>
                          dispatch(
                            updateWeddingInfo({
                              location: e.target.value,
                              date: weddingInfo.date,
                              type: weddingInfo.type,
                              names: weddingInfo.names,
                              customFieldValues: weddingInfo.customFieldValues,
                            }),
                          )
                        }
                        className="pl-10 h-12 bg-gray-50 dark:bg-slate-800 border-gray-200 dark:border-gray-700"
                      />
                      <MapPin className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-purple-600" />
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>

          {/* Update Timeline Details section to match Categories style and make it expandable */}
          {timelineItems.length > 0 && reduxEventTypes
            .find((et) => et.type === weddingInfo.type)
            ?.customFields?.length > 0 && (
            <div className="mb-6 bg-white dark:bg-slate-800 rounded-lg border shadow-sm overflow-hidden">
              <div 
                className="p-4 flex items-center justify-between cursor-pointer bg-gradient-to-r from-purple-50 to-indigo-50 dark:from-purple-900/20 dark:to-indigo-900/20 hover:from-purple-100 hover:to-indigo-100 dark:hover:from-purple-900/30 dark:hover:to-indigo-900/30 transition-colors"
                onClick={() => setShowTimelineDetails(!showTimelineDetails)}
              >
                <div className="flex items-center">
                  <ClipboardList className="h-5 w-5 mr-2 text-purple-600" />
                  <h3 className="text-lg font-medium">Additional Details</h3>
                </div>
                <ChevronDown
                  className={`h-5 w-5 text-purple-600 transition-transform ${
                    showTimelineDetails ? "transform rotate-180" : ""
                  }`}
                />
              </div>
              {showTimelineDetails && (
                <div className="p-6">
                  <div className="space-y-4">
                    {reduxEventTypes
                      .find((et) => et.type === weddingInfo.type)
                      ?.customFields?.map((field) => (
                        <div key={field.id} className="space-y-2">
                          <Label htmlFor={field.id}>{field.name}</Label>
                          {field.type === "text" && (
                            <Input
                              id={field.id}
                              value={
                                // @ts-ignore - Type compatibility issue with custom fields
                                weddingInfo.customFieldValues?.[field.id] ??
                                field.defaultValue ??
                                ""
                              }
                              onChange={(e) =>
                                dispatch(
                                  updateWeddingInfo({
                                    ...weddingInfo,
                                    customFieldValues: {
                                      ...(weddingInfo.customFieldValues || {}),
                                      [field.id]: e.target.value,
                                    },
                                  }),
                                )
                              }
                              className="w-full"
                            />
                          )}
                          {field.type === "number" && (
                            <Input
                              id={field.id}
                              type="number"
                              value={
                                // @ts-ignore - Type compatibility issue with custom fields
                                weddingInfo.customFieldValues?.[field.id] ??
                                field.defaultValue ??
                                ""
                              }
                              onChange={(e) =>
                                dispatch(
                                  updateWeddingInfo({
                                    ...weddingInfo,
                                    customFieldValues: {
                                      ...(weddingInfo.customFieldValues || {}),
                                      [field.id]: parseFloat(e.target.value),
                                    },
                                  }),
                                )
                              }
                              className="w-full"
                            />
                          )}
                          {field.type === "boolean" && (
                            <div className="flex items-center space-x-2">
                              <Switch
                                id={field.id}
                                checked={
                                  // @ts-ignore - Type compatibility issue with custom fields
                                  weddingInfo.customFieldValues?.[field.id] ??
                                  field.defaultValue ??
                                  false
                                }
                                onCheckedChange={(checked) =>
                                  dispatch(
                                    updateWeddingInfo({
                                      ...weddingInfo,
                                      customFieldValues: {
                                        ...(weddingInfo.customFieldValues || {}),
                                        [field.id]: checked,
                                      },
                                    }),
                                  )
                                }
                              />
                              <Label htmlFor={field.id}>Enabled</Label>
                            </div>
                          )}
                          {field.type === "date" && (
                            <div className="grid gap-2">
                              <Popover>
                                <PopoverTrigger asChild>
                                  <Button
                                    variant="outline"
                                    className={cn(
                                      "w-full justify-start text-left font-normal",
                                      !weddingInfo.customFieldValues?.[field.id] &&
                                        "text-muted-foreground",
                                    )}
                                  >
                                    <CalendarIcon className="mr-2 h-4 w-4 text-purple-600" />
                                    {weddingInfo.customFieldValues?.[field.id] ? (
                                      format(
                                        new Date(
                                          weddingInfo.customFieldValues[
                                            field.id
                                          ] as string,
                                        ),
                                        "PPP",
                                      )
                                    ) : (
                                      <span>Pick a date</span>
                                    )}
                                  </Button>
                                </PopoverTrigger>
                                <PopoverContent className="w-auto p-0">
                                  <Calendar
                                    mode="single"
                                    selected={
                                      weddingInfo.customFieldValues?.[field.id]
                                        ? new Date(
                                            weddingInfo.customFieldValues[
                                              field.id
                                            ] as string,
                                          )
                                        : undefined
                                    }
                                    onSelect={(date) =>
                                      dispatch(
                                        updateWeddingInfo({
                                          ...weddingInfo,
                                          customFieldValues: {
                                            ...(weddingInfo.customFieldValues || {}),
                                            [field.id]: date?.toISOString(),
                                          },
                                        }),
                                      )
                                    }
                                    initialFocus
                                    className="border-none"
                                    classNames={{
                                      day_selected: "bg-purple-600 text-white hover:bg-purple-700 hover:text-white focus:bg-purple-600 focus:text-white",
                                      day_today: "bg-purple-100 text-purple-900",
                                    }}
                                  />
                                </PopoverContent>
                              </Popover>
                            </div>
                          )}
                        </div>
                      ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Settings section with heading */}
          <div className="mb-6 bg-white dark:bg-slate-800 rounded-lg border shadow-sm overflow-hidden">
            <div 
              className="p-4 flex items-center justify-between cursor-pointer bg-gradient-to-r from-purple-50 to-indigo-50 dark:from-purple-900/20 dark:to-indigo-900/20 hover:from-purple-100 hover:to-indigo-100 dark:hover:from-purple-900/30 dark:hover:to-indigo-900/30 transition-colors"
              onClick={() => setShowSettings(!showSettings)}
            >
              <div className="flex items-center">
                <Settings className="h-5 w-5 mr-2 text-purple-600" />
                <h3 className="text-lg font-medium">Settings</h3>
              </div>
              <ChevronDown
                className={`h-5 w-5 text-purple-600 transition-transform ${
                  showSettings ? "transform rotate-180" : ""
                }`}
              />
            </div>
            {showSettings && (
              <div className="p-4">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  <div className="flex items-center space-x-2">
                    <Switch
                      id="show-categories"
                      checked={showCategories}
                      onCheckedChange={handleCategoryToggle}
                      className="data-[state=checked]:bg-purple-600"
                    />
                    <Label htmlFor="show-categories" className="text-base font-medium">Enable Categories</Label>
                  </div>

                  {!isTemplate && (
                    <div className="flex items-center space-x-2">
                      <Switch
                        id="show-vendors"
                        checked={showVendors}
                        onCheckedChange={(checked) => setShowVendors(checked)}
                        className="data-[state=checked]:bg-purple-600"
                      />
                      <Label htmlFor="show-vendors" className="text-base font-medium">Enable Participants</Label>
                    </div>
                  )}
                </div>
              </div>
            )}
          </div>

          {/* Categories Section - moved below Timeline Details */}
          {(showCategories || isTemplate) && (
            <div className="mb-6 bg-white dark:bg-slate-800 rounded-lg border shadow-sm overflow-hidden">
              <div 
                className="p-3 flex items-center justify-between cursor-pointer bg-gradient-to-r from-purple-50 to-indigo-50 dark:from-purple-900/20 dark:to-indigo-900/20 hover:from-purple-100 hover:to-indigo-100 dark:hover:from-purple-900/30 dark:hover:to-indigo-900/30 transition-colors"
                onClick={() => setShowCategoriesSection(!showCategoriesSection)}
              >
                <div className="flex items-center">
                  <Layers className="h-5 w-5 mr-2 text-purple-600" />
                  <h3 className="text-lg font-medium">Categories</h3>
                </div>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={(e) => {
                      e.stopPropagation();
                      handleAddCategory();
                    }}
                    className="bg-purple-50 border-purple-200 text-purple-700 hover:bg-purple-100 hover:text-purple-800 dark:bg-purple-900/20 dark:border-purple-800 dark:text-purple-300"
                  >
                    <Plus className="h-4 w-4 mr-2 text-purple-600" />
                    Add Category
                  </Button>
                  <ChevronDown
                    className={`h-5 w-5 text-purple-600 transition-transform ${
                      showCategoriesSection ? "transform rotate-180" : ""
                    }`}
                  />
                </div>
              </div>
              {showCategoriesSection && (
                <div className="p-3">
                  {categories.length === 0 ? (
                    <div className="text-center py-3 text-muted-foreground">
                      No categories yet. Add one to organize your timeline.
                    </div>
                  ) : (
                    <div className="space-y-2">
                      {categories.map((category, index) => (
                        <CategoryItem
                          key={category.id}
                          category={category}
                          index={index}
                          onEdit={() => {
                            setEditingCategory(category);
                            setShowCategoryDialog(true);
                          }}
                          onDelete={() => handleDeleteCategory(category.id)}
                          moveCategory={moveCategory}
                        />
                      ))}
                    </div>
                  )}
                </div>
              )}
            </div>
          )}
        </>
      )}

      {/* Timeline Vendors section */}
      {!isTemplate && showVendors && (
        <div className="mb-6 bg-white dark:bg-slate-800 rounded-lg border shadow-sm overflow-hidden">
          <div 
            className="p-4 flex items-center justify-between cursor-pointer bg-gradient-to-r from-purple-50 to-indigo-50 dark:from-purple-900/20 dark:to-indigo-900/20 hover:from-purple-100 hover:to-indigo-100 dark:hover:from-purple-900/30 dark:hover:to-indigo-900/30 transition-colors"
            onClick={() => setShowVendorsContent(!showVendorsContent)}
          >
            <div className="flex items-center">
              <Users className="h-5 w-5 mr-2 text-purple-600" />
              <h3 className="text-lg font-medium">Participants</h3>
            </div>
            <div className="flex items-center gap-2">
              <VendorSelector 
                timelineId={timelineId !== null ? timelineId : undefined} 
                isTimelineVendor={true}
                onVendorsChange={() => {
                  // Force refresh of all timeline items to show updated participants
                  setStateItems(prevItems => [...prevItems]);
                  
                  // Refresh the participant display
                  if (timelineVendorDisplayRef.current) {
                    timelineVendorDisplayRef.current.refreshVendors();
                  }
                  
                  // Refresh all timeline item participant selectors
                  refreshTimelineItemVendors();
                }}
                buttonLabel="Add Participants"
              />
              <ChevronDown
                className={`h-5 w-5 text-purple-600 transition-transform ${
                  showVendorsContent ? "transform rotate-180" : ""
                }`}
              />
            </div>
          </div>
          {showVendorsContent && (
            <div className="p-4">
              <div className="p-3 bg-gray-50 dark:bg-slate-700 rounded-md border border-gray-200 dark:border-gray-600">
                <VendorSelectorDisplay 
                  timelineId={timelineId !== null ? timelineId : undefined} 
                  isTimelineVendor={true}
                  showEditHint={false}
                  ref={timelineVendorDisplayRef}
                  showVendorTypes={showVendorTypes}
                />
              </div>
            </div>
          )}
        </div>
      )}
          
          <div className="mt-8 border-t pt-8">
                <h2 className="text-2xl font-serif mb-6">
                  <span className="bg-gradient-to-r from-purple-600 to-indigo-600 bg-clip-text text-transparent">Items</span>
                </h2>
          </div>


          {/* Timeline Items section */}
          <div className="flex items-center justify-between mb-6">
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => dispatch(setBulkEditMode(!bulkEditMode))}
                className={bulkEditMode ? "bg-purple-600 hover:bg-purple-700 text-white" : "bg-white dark:bg-slate-800"}
              >
                <Edit2 className={`h-4 w-4 mr-2 ${bulkEditMode ? 'text-white' : 'text-purple-600'}`} />
                {bulkEditMode ? "Exit Bulk Edit" : "Bulk Edit"}
              </Button>
              {!isTemplate && showVendors && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => setShowBulkVendorDialog(true)}
                  className="bg-white dark:bg-slate-800"
                >
                  <Users className="h-4 w-4 mr-2 text-purple-600" />
                  Bulk Assign
                </Button>
              )}
            </div>
            <div className="flex items-center gap-2">
              <Button
                variant="outline"
                size="sm"
                onClick={() => dispatch(undo())}
                disabled={!canUndo}
                className="bg-white dark:bg-slate-800"
              >
                <Undo2 className="w-4 h-4 mr-2 text-purple-600" /> Undo
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={() => dispatch(redo())}
                disabled={!canRedo}
                className="bg-white dark:bg-slate-800"
              >
                <Redo2 className="w-4 h-4 mr-2 text-purple-600" /> Redo
              </Button>
            </div>
          </div>

      {/* Bulk Edit Controls */}
      {bulkEditMode && (
        <div className="mb-6 p-4 bg-gradient-to-r from-purple-50 to-indigo-50 dark:from-purple-900/20 dark:to-indigo-900/20 rounded-lg border border-purple-200 dark:border-purple-800 shadow-sm">
          <BulkEditControls
            onTimeShift={handleTimeShift}
            timeAdjustments={[5, 10, 15, 20, 25, 30, 40, 50, 60]}
            onSelectAllInCategory={handleSelectAllInCategory}
            onClearSelection={handleClearSelection}
            selectedCount={selectedItems.length}
            categories={categories}
            onDeleteSelected={handleDeleteSelected}
          />
        </div>
      )}
      
{/* View Options section with heading */}
          <div className="mb-6 bg-white dark:bg-slate-800 rounded-lg border shadow-sm overflow-hidden">
            <div 
              className="p-4 flex items-center justify-between cursor-pointer bg-gradient-to-r from-purple-50 to-indigo-50 dark:from-purple-900/20 dark:to-indigo-900/20 hover:from-purple-100 hover:to-indigo-100 dark:hover:from-purple-900/30 dark:hover:to-indigo-900/30 transition-colors"
              onClick={() => setShowViewOptions(!showViewOptions)}
            >
              <div className="flex items-center">
                <Eye className="h-5 w-5 mr-2 text-purple-600" />
                <h3 className="text-lg font-medium">View Options</h3>
              </div>
              <ChevronDown
                className={`h-5 w-5 text-purple-600 transition-transform ${
                  showViewOptions ? "transform rotate-180" : ""
                }`}
              />
            </div>
            {showViewOptions && (
              <div className="p-4">
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-3">
                  <div className="flex items-center space-x-2">
                    <Switch
                      id="show-descriptions"
                      checked={showDescriptions}
                      onCheckedChange={(checked) => setShowDescriptions(checked)}
                      className="data-[state=checked]:bg-purple-600"
                    />
                    <Label htmlFor="show-descriptions" className="text-base font-medium">Descriptions</Label>
                  </div>

                  <div className="flex items-center space-x-2">
                    <Switch
                      id="show-locations"
                      checked={showLocations}
                      onCheckedChange={(checked) => setShowLocations(checked)}
                      className="data-[state=checked]:bg-purple-600"
                    />
                    <Label htmlFor="show-locations" className="text-base font-medium">Locations</Label>
                  </div>

                  <div className="flex items-center space-x-2">
                    <Switch
                      id="show-end-times"
                      checked={showEndTimes}
                      onCheckedChange={(checked) => setShowEndTimes(checked)}
                      className="data-[state=checked]:bg-purple-600"
                    />
                    <Label htmlFor="show-end-times" className="text-base font-medium">End Times</Label>
                  </div>

                  <div className="flex items-center space-x-2">
                    <Switch
                      id="show-durations"
                      checked={showDurations}
                      onCheckedChange={(checked) => setShowDurations(checked)}
                      className="data-[state=checked]:bg-purple-600"
                    />
                    <Label htmlFor="show-durations" className="text-base font-medium">Durations</Label>
                  </div>

                  <div className="flex items-center space-x-2">
                    <Switch
                      id="show-icons"
                      checked={showIcons}
                      onCheckedChange={(checked) => setShowIcons(checked)}
                      className="data-[state=checked]:bg-purple-600"
                    />
                    <Label htmlFor="show-icons" className="text-base font-medium">Icons</Label>
                  </div>

                  {showCategories && (
                    <div className="flex items-center space-x-2">
                      <Switch
                        id="show-categories-on-items"
                        checked={showCategoriesOnItems}
                        onCheckedChange={(checked) => setShowCategoriesOnItems(checked)}
                        className="data-[state=checked]:bg-purple-600"
                      />
                      <Label htmlFor="show-categories-on-items" className="text-base font-medium">Categories</Label>
                    </div>
                  )}

                  {showVendors && (
                    <div className="flex items-center space-x-2">
                      <Switch
                        id="show-vendors-on-items"
                        checked={showVendorsOnItems}
                        onCheckedChange={(checked) => setShowVendorsOnItems(checked)}
                        className="data-[state=checked]:bg-purple-600"
                      />
                      <Label htmlFor="show-vendors-on-items" className="text-base font-medium">Participants</Label>
                    </div>
                  )}

                  {showVendors && (
                    <div className="flex items-center space-x-2">
                      <Switch
                        id="show-vendor-types"
                        checked={showVendorTypes}
                        onCheckedChange={(checked) => setShowVendorTypes(checked)}
                        className="data-[state=checked]:bg-purple-600"
                      />
                      <Label htmlFor="show-vendor-types" className="text-base font-medium">Show Vendor Types</Label>
                    </div>
                  )}
                </div>
              </div>
            )}
          </div>

      {/* Timeline Items */}
      <div className="space-y-4">
        <TimelineView
          items={timelineItems}
          categories={categories}
          onUpdateItem={handleUpdateItem}
          onDeleteItem={handleDeleteItem}
          onMoveItem={handleMoveItem}
          onAddItem={handleAddItem}
          newItemId={localNewItemId}
          bulkEditMode={bulkEditMode}
          selectedItems={selectedItems}
          onSelectItem={(id) => dispatch(toggleItemSelection(id))}
          showCategories={showCategories}
          showLocations={showLocations}
          showDescriptions={showDescriptions}
          showEndTimes={showEndTimes}
          showDurations={showDurations}
          showIcons={showIcons}
          showCategoriesOnItems={showCategoriesOnItems}
          showVendorsOnItems={showVendorsOnItems}
          showVendorTypes={showVendorTypes}
          timelineId={timelineId !== null ? timelineId : undefined}
          showVendors={showVendors}
          onUpdateCustomFields={handleUpdateCustomFields}
        />
      </div>

      {/* Category Edit Dialog */}
      <CategoryEditDialog
        category={editingCategory || { id: "", name: "", description: "", order: 0 }}
        onSave={handleEditCategory}
        onCancel={() => setShowCategoryDialog(false)}
        open={showCategoryDialog}
      />

      {/* Reset Confirmation Dialog */}
      <AlertDialog open={showResetDialog} onOpenChange={setShowResetDialog}>
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Are you sure?</AlertDialogTitle>
            <AlertDialogDescription>
              This will reset all timeline data. This action cannot be undone.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="bg-white hover:bg-gray-100 dark:bg-slate-800 dark:hover:bg-slate-700">Cancel</AlertDialogCancel>
            <AlertDialogAction className="bg-purple-600 hover:bg-purple-700">
              Reset
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Apply Template Dialog */}
      <AlertDialog
        open={showTemplateConfirmDialog}
        onOpenChange={setShowTemplateConfirmDialog}
      >
        <AlertDialogContent>
          <AlertDialogHeader>
            <AlertDialogTitle>Apply Template</AlertDialogTitle>
            <AlertDialogDescription>
              This will replace your current timeline with the selected template.
              Any unsaved changes will be lost.
            </AlertDialogDescription>
          </AlertDialogHeader>
          <AlertDialogFooter>
            <AlertDialogCancel className="bg-white hover:bg-gray-100 dark:bg-slate-800 dark:hover:bg-slate-700">Cancel</AlertDialogCancel>
            <AlertDialogAction 
              onClick={handleTemplateConfirm}
              className="bg-purple-600 hover:bg-purple-700"
            >
              Apply Template
            </AlertDialogAction>
          </AlertDialogFooter>
        </AlertDialogContent>
      </AlertDialog>

      {/* Templates Dialog */}
      <Dialog open={saveTemplateDialogOpen} onOpenChange={setSaveTemplateDialogOpen}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Templates</DialogTitle>
            <DialogDescription>
              Apply a template to your timeline or create a new one
            </DialogDescription>
          </DialogHeader>

          <div className="grid gap-6 py-4">
            <h3 className="font-medium text-purple-600">Available Templates</h3>
            {templates.length === 0 ? (
              <div className="text-center py-6 text-muted-foreground">
                No templates available. Save your timeline as a template to create one.
              </div>
            ) : (
              <div className="grid gap-4">
                {templates.map((template) => (
                  <div
                    key={template.id}
                    className="flex items-center justify-between p-4 rounded-md border hover:border-purple-300 dark:hover:border-purple-700 bg-white dark:bg-slate-800 transition-colors"
                  >
                    <div>
                      <h4 className="font-medium">{template.title}</h4>
                      <p className="text-sm text-muted-foreground">
                        {template.events?.length || 0} events
                      </p>
                    </div>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={() => {
                        applyTemplate(template.id);
                        setSaveTemplateDialogOpen(false);
                      }}
                      className="bg-white hover:bg-gray-100 dark:bg-slate-800 dark:hover:bg-slate-700"
                    >
                      Apply
                    </Button>
                  </div>
                ))}
              </div>
            )}
          </div>
        </DialogContent>
      </Dialog>

      {/* Export Dialog */}
      {renderExportDialog()}

      {showBulkVendorDialog && timelineId && timelineId > 0 && (
        <VendorBulkAssignDialog
          timelineId={timelineId !== null ? timelineId : undefined}
          items={stateItems}
          open={showBulkVendorDialog}
          onOpenChange={(open) => {
            setShowBulkVendorDialog(open);
            if (!open) {
              // When dialog closes, refresh all timeline items to show updated participants
              setStateItems(prevItems => [...prevItems]);
              refreshTimelineItemVendors();
            }
          }}
        />
      )}
    </div>
  );
}

interface TimelineImage {
  id: number;
  timelineId: number;
  imageUrl: string;
  caption?: string;
  order: number;
}

</rewritten_file>
</rewritten_file>